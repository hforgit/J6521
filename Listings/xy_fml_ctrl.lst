C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE XY_FML_CTRL
OBJECT MODULE PLACED IN .\Objects\xy_fml_ctrl.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE 02_FML\xy_fml_ctrl.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\01_APL;.\
                    -02_FML;.\03_HAL;.\04_SYS) DEBUG PRINT(.\Listings\xy_fml_ctrl.lst) OBJECT(.\Objects\xy_fml_ctrl.obj)

line level    source

   1          #include "xy_sys_headfile.h"
   2          
   3          /*********************************************************************************************************
             -**************
   4          * Function Name: 
   5          * Description  : 
   6          * Arguments    : None
   7          * Return Value : None
   8          **********************************************************************************************************
             -*************/
   9          void fml_ctrl_init_reg(void)
  10          {
  11   1              hal_port_init();
  12   1              hal_timer_Init();
  13   1              hal_serial_Init();
  14   1      }
  15          
  16          /*********************************************************************************************************
             -**************
  17          * Function Name: 
  18          * Description  : 
  19          * Arguments    : None
  20          * Return Value : None
  21          **********************************************************************************************************
             -*************/
  22          void fml_ctrl_init_data(datall* p_data)
  23          {
  24   1              p_data->remote.workmode.workmode_current        = WORKMODULE_DEFAULT;
  25   1              p_data->remote.keyctrl.keystate_light           = OFF;
  26   1              p_data->remote.keyctrl.keystate_swing           = OFF;
  27   1              p_data->remote.keyctrl.keystate_ptc             = OFF;
  28   1              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
  29   1              p_data->remote.keyctrl.keystate_fan_absorb      = OFF;
  30   1              p_data->remote.keyctrl.keystate_ptc_wait        = OFF;
  31   1      
  32   1              p_data->remote.keyctrl.keystate_swing_pri       = OFF;
  33   1              p_data->remote.keyctrl.keystate_enter_swing = RESET;
  34   1      
  35   1              p_data->remote.workmode.flag_workdelay_1s       = SET;
  36   1              p_data->remote.workmode.flag_workdelay_10s      = SET;
  37   1              p_data->remote.workmode.workdelay_1s            = CLOCK_DELAYTIMER_0S;
  38   1              p_data->remote.workmode.workdelay_10s           = CLOCK_DELAYTIMER_10S;
  39   1      
  40   1              p_data->remote.workmode.flag_work_colddry       = NO;
  41   1              p_data->remote.workmode.flag_work_warmdry       = NO;
  42   1      
  43   1              p_data->uart.rec_protocol                                       = RESET;
  44   1      
  45   1              p_data->uart.send_data                                          = 0;
  46   1              p_data->display.disp_icon_data                          = 0;
  47   1      }
  48          
  49          /*********************************************************************************************************
             -**************
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 2   

  50          * Function Name: 
  51          * Description  : 
  52          * Arguments    : None
  53          * Return Value : None
  54          **********************************************************************************************************
             -*************/
  55          void fml_ctrl_chk_error(datall* p_data)
  56          {
  57   1              datacommon       err;
  58   1              unsigned int motor[4] = {0};
  59   1              switchstate  state[3] = {0};
  60   1      
  61   1              motor[0] = p_data->motor.blow_target_step;
  62   1              motor[1] = p_data->motor.absorb_target_step;
  63   1              motor[2] = p_data->motor.blow_motor_step;
  64   1              motor[3] = p_data->motor.absorb_motor_step;
  65   1              state[0] = p_data->remote.keyctrl.keystate_fan_blow;
  66   1              state[1] = p_data->remote.keyctrl.keystate_fan_absorb;
  67   1              state[2] = p_data->remote.keyctrl.keystate_ptc;
  68   1              err.dat  = 0;
  69   1      
  70   1              if(YES == CTRL_CHECK_ERROR_NUMB_1(motor[0], motor[1], state[0], state[1], state[2]))
  71   1              {
  72   2                      p_data->motor.blow_target_step = RESET_STEP_ZERO;
  73   2                      err.bits.b0 = 1;
  74   2              }
  75   1      
  76   1              if(YES == CTRL_CHECK_ERROR_NUMB_2(motor[0], motor[1], state[0], state[1], state[2]))
  77   1              {
  78   2                      p_data->motor.absorb_target_step = RESET_STEP_ZERO;
  79   2                      err.bits.b1 = 1;
  80   2              }
  81   1      
  82   1              if(YES == CTRL_CHECK_ERROR_NUMB_3(motor[0], motor[1], state[0], state[1], state[2]))
  83   1              {
  84   2                      p_data->motor.absorb_target_step = RESET_STEP_ZERO;
  85   2                      err.bits.b2 = 1;
  86   2              }
  87   1      
  88   1              if(YES == CTRL_CHECK_ERROR_NUMB_4(motor[0], motor[1], state[0], state[1], state[2])) 
  89   1              {
  90   2                      p_data->remote.keyctrl.keystate_fan_blow = OFF;
  91   2                      err.bits.b3 = 1;
  92   2              }
  93   1      
  94   1              if(YES == CTRL_CHECK_ERROR_NUMB_5(motor[0], motor[2], state[0], state[1], state[2]))
  95   1              {
  96   2                      if(p_data->motor.blow_motor_step && (NO == MOTOR_CHK_STEP_IS_LEGAL(p_data->motor.blow_motor_step)))             //?
  97   2                      {
  98   3                              p_data->remote.keyctrl.keystate_open_swing = OFF;
  99   3                      }
 100   2      
 101   2                      if(OFF == p_data->remote.keyctrl.keystate_open_swing)
 102   2                      {
 103   3                              p_data->remote.keyctrl.keystate_fan_blow = OFF;
 104   3                              err.bits.b4 = 1;
 105   3                      }
 106   2              }
 107   1      
 108   1              if(YES == CTRL_CHECK_ERROR_NUMB_6(motor[1], motor[3], state[0], state[1], state[2]))
 109   1              {
 110   2                      p_data->remote.keyctrl.keystate_fan_blow = OFF;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 3   

 111   2                      err.bits.b5 = 1;
 112   2              }
 113   1      
 114   1              if(YES == CTRL_CHECK_ERROR_NUMB_7(motor[0], motor[1], state[0], state[1], state[2]))
 115   1              {
 116   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
 117   2                      err.bits.b6 = 1;
 118   2              }
 119   1      
 120   1              p_data->error.dat = err.dat;    
 121   1      }
 122          
 123          /*********************************************************************************************************
             -**************
 124          * Function Name: 
 125          * Description  : 
 126          * Arguments    : None
 127          * Return Value : None
 128          **********************************************************************************************************
             -*************/
 129          void fml_ctrl_icon_display(datall* p_data)
 130          {       
 131   1              #ifdef XY_SYS_TEST_MODE
 132   1                      if(YES == p_data->testmode)
 133   1                              return;
 134   1              #endif
 135   1              
 136   1              if(REMOTE != p_data->keytype)
 137   1                      return;
 138   1              
 139   1              switch(p_data->remote.workmode.workmode_current)
 140   1              {
 141   2                      case WORKMODULE_STANDBY:
 142   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)                //workdelay!
 143   2                              {
 144   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_STANDBY;
 145   3                              }
 146   2                              else
 147   2                              {
 148   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 149   3                              }
 150   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 151   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 152   2                              break;
 153   2                      case WORKMODULE_BLOW:
 154   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;
 155   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 156   2                              p_data->display.disp_icon_blow      = SYM_BLOW_ON;
 157   2                              break;
 158   2                      case WORKMODULE_WARM:
 159   2                              p_data->display.disp_icon_warm      = SYM_WARM_ON;
 160   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 161   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 162   2                              break;
 163   2                      case WORKMODULE_ABSORB:
 164   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)
 165   2                              {
 166   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_ABSORB;
 167   3                              }
 168   2                              else
 169   2                              {
 170   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 4   

 171   3                              }       
 172   2                              p_data->display.disp_icon_absorb  = SYM_ABSORB_ON;
 173   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 174   2                              break;
 175   2                      default:
 176   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;                              
 177   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 178   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 179   2                              break;
 180   2              }
 181   1      }
 182          
 183          /*********************************************************************************************************
             -**************
 184          * Function Name: 
 185          * Description  : 
 186          * Arguments    : None
 187          * Return Value : None
 188          **********************************************************************************************************
             -*************/
 189          void fml_ctrl_recv_old_version(datall* p_data)
 190          {
 191   1              unsigned char i;
 192   1              unsigned char temp_sum = 0;
 193   1              unsigned char buffer[sizeof(p_data->uart.rec_uart1_dat)] = {0};
 194   1      
 195   1              memcpy(buffer, p_data->uart.rec_uart1_dat, sizeof(buffer));
 196   1              memset(p_data->uart.rec_uart1_dat, 0, sizeof(buffer));
 197   1      
 198   1              for(i=0; i<5; i++)
 199   1              {
 200   2                      temp_sum += buffer[i];
 201   2              }
 202   1      
 203   1              if(temp_sum == buffer[i])                       ///< check data 
 204   1              {
 205   2                      p_data->remote.key.keyremote.dat = buffer[2] + (buffer[3]<<8);
 206   2      
 207   2                      if(p_data->remote.key.keyremote.bits.b0)
 208   2                      {
 209   3                              p_data->remote.key.keysta = KEY_LIGHT;
 210   3                      }
 211   2                      else if(p_data->remote.key.keyremote.bits.b1)
 212   2                      {
 213   3                              p_data->remote.key.keysta = KEY_BLOW;
 214   3                      }
 215   2                      else if(p_data->remote.key.keyremote.bits.b2)
 216   2                      {
 217   3                              p_data->remote.key.keysta = KEY_ABSORB;
 218   3                      }
 219   2                      else if(p_data->remote.key.keyremote.bits.b3)
 220   2                      {
 221   3                              p_data->remote.key.keysta = KEY_WARM;
 222   3                      }
 223   2                      else if(p_data->remote.key.keyremote.bits.b4)
 224   2                      {
 225   3                              p_data->remote.key.keysta = KEY_SWING;
 226   3                      }
 227   2                      else if(p_data->remote.key.keyremote.bits.b5)
 228   2                      {
 229   3                              p_data->remote.key.keysta = KEY_RAV;
 230   3                      }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 5   

 231   2                      else if(p_data->remote.key.keyremote.bits.b6)
 232   2                      {
 233   3                              p_data->remote.key.keysta = KEY_COLD_DRY;
 234   3                      }
 235   2                      else if(p_data->remote.key.keyremote.bits.b7)
 236   2                      {
 237   3                              p_data->remote.key.keysta = KEY_STANDBY;
 238   3                      }
 239   2                      else if(p_data->remote.key.keyremote.bits.b8)
 240   2                      {
 241   3                              p_data->remote.key.keysta = KEY_WARM_DRY;
 242   3                      }
 243   2      
 244   2                      if(KEY_RELEASE != p_data->remote.key.keysta)
 245   2                      {
 246   3                              if(TOUCH == p_data->keytype)
 247   3                              {
 248   4                                      memset(&p_data->touch, 0, sizeof(p_data->touch));
 249   4                                      fml_ctrl_init_data(p_data);
 250   4                                      p_data->keytype = REMOTE;
 251   4                              }
 252   3                      }
 253   2      
 254   2                      p_data->temperature.value = buffer[4];
 255   2              }
 256   1      }
 257          
 258          /*********************************************************************************************************
             -**************
 259          * Function Name: 
 260          * Description  : 
 261          * Arguments    : None
 262          * Return Value : None
 263          **********************************************************************************************************
             -*************/
 264          void fml_ctrl_recv_new_version(datall* p_data)
 265          {
 266   1              static displaycontrol   s_dispbuffer;
 267   1              
 268   1              s_dispbuffer.length    = p_data->uart.rec_uart1_dat[2];
 269   1              s_dispbuffer.version   = p_data->uart.rec_uart1_dat[3];
 270   1              s_dispbuffer.sequence  = p_data->uart.rec_uart1_dat[4];
 271   1              s_dispbuffer.command   = (dispcommand)p_data->uart.rec_uart1_dat[5];
 272   1              s_dispbuffer.p_buffer  = &p_data->uart.rec_uart1_dat[6];
 273   1              s_dispbuffer.checkcode = p_data->uart.rec_uart1_dat[s_dispbuffer.length + 2];
 274   1      
 275   1              /* match check code about CRC-8 */
 276   1              if(hal_alg_chk_crc8(p_data->uart.rec_uart1_dat,s_dispbuffer.length + 2) == s_dispbuffer.checkcode)                      ///<
             - check data
 277   1              {
 278   2                      switch(s_dispbuffer.command)
 279   2                      {
 280   3                              case DISPLAY_CMD_REMOTE:
 281   3                                      fml_display_ack_remote(&s_dispbuffer);
 282   3                                      p_data->remote.key.keysta = fml_display_deal_remote(s_dispbuffer.p_buffer);
 283   3                                      if(KEY_RELEASE != p_data->remote.key.keysta)
 284   3                                      {
 285   4                                              if(TOUCH == p_data->keytype)
 286   4                                              {
 287   5                                                      memset(&p_data->touch, 0, sizeof(p_data->touch));
 288   5                                                      fml_ctrl_init_data(p_data);
 289   5                                                      p_data->keytype = REMOTE;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 6   

 290   5                                              }
 291   4                                      }
 292   3                                      break;
 293   3                              case DISPLAY_CMD_TEMP:
 294   3                                      p_data->temperature.value = hal_ad_cal_temperature(s_dispbuffer.p_buffer);
 295   3                                      break;
 296   3                              case DISPLAY_CMD_DIGITAL:
 297   3                                      break;
 298   3                              default:
 299   3                                      break;
 300   3                      }
 301   2              }       
 302   1              memset(p_data->uart.rec_uart1_dat, 0, s_dispbuffer.length + 3);
 303   1      }
 304          
 305          /*********************************************************************************************************
             -**************
 306          * Function Name: 
 307          * Description  : 
 308          * Arguments    : None
 309          * Return Value : None
 310          **********************************************************************************************************
             -*************/
 311          void fml_ctrl_recv_display(datall* p_data)
 312          {
 313   1              if(p_data->uart.rec_uart1_ok)
 314   1              {
 315   2                      p_data->uart.rec_uart1_ok = 0;
 316   2                      switch(p_data->uart.rec_protocol)
 317   2                      {
 318   3                              case OLD:
 319   3                                      fml_ctrl_recv_old_version(p_data);                      ///< old version(only use remote key)
 320   3                                      break;
 321   3                              case NEW:
 322   3                                      fml_ctrl_recv_new_version(p_data);                      ///< new vesion protocol
 323   3                                      break;
 324   3                              default:
 325   3                                      break;
 326   3                      }
 327   2              }
 328   1      }
 329          
 330          /*********************************************************************************************************
             -**************
 331          * Function Name: 
 332          * Description  : 
 333          * Arguments    : None
 334          * Return Value : None
 335          **********************************************************************************************************
             -*************/
 336          void fml_ctrl_deal_key(datall* p_data)
 337          {       
 338   1              switch(p_data->remote.key.keysta)
 339   1              {
 340   2                      case KEY_STANDBY:
 341   2                              if(KEY_STANDBY != p_data->remote.key.keysta_pri)
 342   2                              {
 343   3                                      p_data->remote.key.keysta_pri = KEY_STANDBY;
 344   3      
 345   3                                      p_data->buzzer.normal_bee_on = ON;
 346   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 347   3      
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 7   

 348   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 349   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 350   3                              }
 351   2                              else
 352   2                              {
 353   3                                      p_data->buzzer.burn_bee_on = ON;
 354   3                              }
 355   2                              break;
 356   2                      case KEY_BLOW:
 357   2                              if(KEY_BLOW != p_data->remote.key.keysta_pri)
 358   2                              {
 359   3                                      p_data->remote.key.keysta_pri = KEY_BLOW;
 360   3      
 361   3                                      p_data->buzzer.normal_bee_on = ON;
 362   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_BLOW;
 363   3      
 364   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 365   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 366   3                              }
 367   2                              else
 368   2                              {
 369   3                                      p_data->buzzer.burn_bee_on = ON;
 370   3                              }
 371   2                              break;
 372   2                      case KEY_ABSORB:
 373   2                              if(KEY_ABSORB != p_data->remote.key.keysta_pri)
 374   2                              {
 375   3                                      p_data->remote.key.keysta_pri = KEY_ABSORB;
 376   3                                      
 377   3                                      p_data->buzzer.normal_bee_on = ON;
 378   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_ABSORB;
 379   3      
 380   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 381   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 382   3                              }
 383   2                              else
 384   2                              {
 385   3                                      p_data->buzzer.burn_bee_on = ON;
 386   3                              }
 387   2                              break;
 388   2                      case KEY_WARM:
 389   2                              if(KEY_WARM != p_data->remote.key.keysta_pri)                                   
 390   2                              {
 391   3                                      p_data->remote.key.keysta_pri = KEY_WARM;
 392   3      
 393   3                                      p_data->buzzer.normal_bee_on = ON;
 394   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_WARM;
 395   3      
 396   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 397   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 398   3                              }
 399   2                              else
 400   2                              {
 401   3                                      p_data->buzzer.burn_bee_on = ON;
 402   3                              }
 403   2                              break;
 404   2                      case KEY_COLD_DRY:
 405   2                              if(KEY_COLD_DRY != p_data->remote.key.keysta_pri)
 406   2                              {
 407   3                                      p_data->remote.key.keysta_pri = KEY_COLD_DRY;
 408   3                                      
 409   3                                      p_data->buzzer.normal_bee_on = ON;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 8   

 410   3                                      //p_data->remote.workmode.workmode_cur = WORKMODULE_BLOW;
 411   3      
 412   3                                      p_data->remote.workmode.flag_work_colddry = YES;
 413   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 414   3                              }
 415   2                              else
 416   2                              {
 417   3                                      p_data->buzzer.burn_bee_on = ON;
 418   3                              }
 419   2                              break;
 420   2                      case KEY_WARM_DRY:
 421   2                              if(KEY_WARM_DRY != p_data->remote.key.keysta_pri)
 422   2                              {
 423   3                                      p_data->remote.key.keysta_pri = KEY_WARM_DRY;
 424   3                                      
 425   3                                      p_data->buzzer.normal_bee_on = ON;
 426   3                                      //p_data->remote.workmode.workmode_cur = WORKMODULE_WARM;
 427   3                                      
 428   3                                      p_data->remote.workmode.flag_work_warmdry = YES;
 429   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 430   3                              }
 431   2                              else
 432   2                              {
 433   3                                      p_data->buzzer.burn_bee_on = ON;
 434   3                              }
 435   2                              break;
 436   2                      case KEY_SWING:
 437   2                              /* only blow mode or warm mode and dry can enter this condition */
 438   2                              if(((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 439   2                                      || (WORKMODULE_WARM == p_data->remote.workmode.workmode_current)))
 440   2                              {
 441   3                                      p_data->buzzer.normal_bee_on = ON;
 442   3                                      if(OFF == p_data->remote.keyctrl.keystate_swing)
 443   3                                      {
 444   4                                              /* open swing page */
 445   4                                              p_data->remote.keyctrl.keystate_swing = ON;
 446   4                                      }
 447   3                                      else
 448   3                                      {
 449   4                                              /* close swing page */
 450   4                                              p_data->remote.keyctrl.keystate_swing = OFF;
 451   4                                      }
 452   3                              }
 453   2                              else
 454   2                              {
 455   3                                      p_data->buzzer.burn_bee_on = ON;
 456   3                              }
 457   2                              break;
 458   2                      case KEY_LIGHT:
 459   2                              p_data->buzzer.normal_bee_on = ON;
 460   2                              if(OFF == p_data->remote.keyctrl.keystate_light)
 461   2                              {
 462   3                                      p_data->remote.keyctrl.keystate_light = ON;
 463   3                              }
 464   2                              else
 465   2                              {
 466   3                                      p_data->remote.keyctrl.keystate_light = OFF;
 467   3                              }
 468   2                              break;
 469   2                      default:
 470   2                              break;
 471   2              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 9   

 472   1              p_data->remote.key.keysta = KEY_RELEASE;
 473   1      }
 474          
 475          /*********************************************************************************************************
             -**************
 476          * Function Name: 
 477          * Description  : 
 478          * Arguments    : None
 479          * Return Value : None
 480          **********************************************************************************************************
             -*************/
 481          void fml_ctrl_deal_automode(workmoduleflag* p_mode)                                                     //check
 482          {
 483   1              static switchstate       s_onetime  = RESET;
 484   1              static unsigned char s_time_dry_tmp = 0;
 485   1              static unsigned int  s_time_dry_min = 0;
 486   1              static switchstate       s_state    = RESET;
 487   1      
 488   1              if((YES == p_mode->flag_work_warmdry) || (YES == p_mode->flag_work_colddry))
 489   1              {
 490   2                      if(YES == p_mode->flag_work_warmdry)
 491   2                      {
 492   3                              if(WARM != s_state)
 493   3                              {
 494   4                                      s_onetime = RESET;
 495   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 496   4                              }
 497   3                              s_state = WARM;
 498   3                      }
 499   2                      else
 500   2                      {
 501   3                              if(COLD != s_state)
 502   3                              {
 503   4                                      s_onetime = RESET;
 504   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 505   4                              }
 506   3                              s_state = COLD;
 507   3                      }
 508   2                      if(YES == p_mode->flag_work_warmdry)
 509   2                      {
 510   3                              if((s_time_dry_min % (CLOCK_WARMDRY_WARM_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 511   3                                      < (CLOCK_WARMDRY_WARM_10MIN - CLOCK_DELAYTIMER_10S))
 512   3                              {
 513   4                                      p_mode->workmode_current = WORKMODULE_WARM;
 514   4                              }
 515   3                              else
 516   3                              {
 517   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 518   4                              }
 519   3                      }
 520   2                      else
 521   2                      {
 522   3                              if((s_time_dry_min % (CLOCK_COLDDRY_COLD_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 523   3                                      < CLOCK_COLDDRY_COLD_10MIN)
 524   3                              {
 525   4                                      p_mode->workmode_current = WORKMODULE_BLOW;
 526   4                              }
 527   3                              else
 528   3                              {
 529   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 530   4                              }
 531   3                      }               
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 10  

 532   2                      if(RESET == s_onetime)
 533   2                      {
 534   3                              s_onetime = SET;
 535   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 536   3                      }
 537   2                      if(YES == CTRL_EXCEED_DELAY_TIMER(1, p_mode->workdelay_cyc, s_time_dry_tmp))
 538   2                      {
 539   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 540   3                              s_time_dry_min++;
 541   3                              if(s_time_dry_min >= CLOCK_WORKDRY_ALL_60MIN)
 542   3                              {
 543   4                                      p_mode->workmode_current = WORKMODULE_STANDBY;
 544   4                                      if(YES == p_mode->flag_work_warmdry)
 545   4                                      {       
 546   5                                              p_mode->flag_work_warmdry = NO;
 547   5                                      }
 548   4                                      else
 549   4                                      {
 550   5                                              p_mode->flag_work_colddry = NO;
 551   5                                      }
 552   4                              }
 553   3                      }
 554   2              }
 555   1              else
 556   1              {
 557   2                      s_state = RESET;
 558   2              }
 559   1      }
 560          
 561          /*********************************************************************************************************
             -**************
 562          * Function Name: 
 563          * Description  : 
 564          * Arguments    : None
 565          * Return Value : None
 566          **********************************************************************************************************
             -*************/
 567          void fml_ctrl_deal_mode(datall* p_data)
 568          {       
 569   1              static switchstate   s_onetime[2] = {STEP1, RESET};
 570   1              static unsigned char s_timecount_cur = 0, s_timecount_pri = 0;
 571   1              static unsigned char s_time_ptc_worktime = 0;
 572   1      
 573   1              fml_ctrl_deal_automode(&p_data->remote.workmode);
 574   1              switch(p_data->remote.workmode.workmode_current)
 575   1              {
 576   2                      case WORKMODULE_STANDBY:
 577   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 578   2                              {
 579   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 580   3                              }
 581   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 582   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 583   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 584   2                              p_data->remote.key.keysta_pri = KEY_STANDBY;
 585   2                              break;
 586   2                      case WORKMODULE_BLOW:
 587   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 588   2                              {
 589   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 590   3                              }
 591   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 11  

 592   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 593   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 594   2                              break;
 595   2                      case WORKMODULE_WARM:
 596   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)       ///< delay 10s
 597   2                              {
 598   3                                      if(ON == p_data->remote.keyctrl.keystate_move_target)                   ///< move target step
 599   3                                      {
 600   4                                              if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
 601   4                                              {
 602   5                                                      p_data->remote.workmode.flag_workdelay_1s = RESET;
 603   5                                                      p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 604   5                                              }                                       
 605   4                                              p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 606   4                                      }
 607   3                                      else
 608   3                                      {
 609   4                                              p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;             ///< start from last step
 610   4                                      }
 611   3                              }
 612   2                              else
 613   2                              {
 614   3                                      if(STEP3 == s_onetime[0])
 615   3                                      {
 616   4                                              if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
 617   4                                              {
 618   5                                                      if(NO == CTRL_EXCEED_DELAY_TIMER(10, s_timecount_cur, s_timecount_pri))
 619   5                                                      {
 620   6                                                              p_data->remote.workmode.flag_workdelay_1s = SET;
 621   6                                                              p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 622   6                                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 623   6                                                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 624   6                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 625   6                                                      }
 626   5                                              }
 627   4                                      }
 628   3                              }               
 629   2                              if(p_data->remote.workmode.workdelay_1s >= CLOCK_DELAYTIMER_1S)
 630   2                              {
 631   3                                      if((OFF == p_data->remote.keyctrl.keystate_ptc_wait) 
 632   3                              //              && (YES == MOTOR_CHK_MOVE_TO_TARGET))
 633   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))
 634   3                                      {
 635   4                                              p_data->remote.keyctrl.keystate_ptc   = ON;                     ///< restart ptc
 636   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 637   4                                      }
 638   3                              }
 639   2                              break;
 640   2                      case WORKMODULE_ABSORB:
 641   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 642   2                              {
 643   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 644   3                              }
 645   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 646   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 647   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 648   2                              break;
 649   2                      default:
 650   2                              break;
 651   2              }
 652   1              if(p_data->remote.keyctrl.keystate_ptc_pri != p_data->remote.keyctrl.keystate_ptc)
 653   1              {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 12  

 654   2                      if(ON == p_data->remote.keyctrl.keystate_ptc)
 655   2                      {
 656   3                              if(RESET == s_onetime[1])
 657   3                              {
 658   4                                      s_time_ptc_worktime = p_data->remote.workmode.workdelay_cyc;
 659   4                              }
 660   3                              s_onetime[1] = SET;
 661   3                      }
 662   2                      else
 663   2                      {
 664   3                              s_onetime[1] = RESET;
 665   3                      }
 666   2                      p_data->remote.keyctrl.keystate_ptc_pri = p_data->remote.keyctrl.keystate_ptc;  
 667   2              }
 668   1              else
 669   1              {
 670   2                      if(ON == p_data->remote.keyctrl.keystate_ptc_pri)
 671   2                      {
 672   3                              if(YES == CTRL_EXCEED_DELAY_TIMER(0, p_data->remote.workmode.workdelay_cyc, s_time_ptc_worktime))
 673   3                              {
 674   4                                      p_data->remote.keyctrl.keystate_ptc_delay = YES;
 675   4                              }
 676   3                      }
 677   2                      else
 678   2                      {
 679   3                              p_data->remote.keyctrl.keystate_ptc_delay = NO;
 680   3                      }
 681   2              }
 682   1      }
 683          
 684          /*********************************************************************************************************
             -**************
 685          * Function Name: 
 686          * Description  : 
 687          * Arguments    : None
 688          * Return Value : None
 689          **********************************************************************************************************
             -*************/
 690          void fml_ctrl_deal_motor(datall* p_data)
 691          {
 692   1              static switchstate s_step = STEP1;
 693   1      
 694   1              switch(p_data->remote.workmode.workmode_current)
 695   1              {
 696   2                      case WORKMODULE_STANDBY:
 697   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 698   2                              {
 699   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 700   3                                      p_data->motor.absorb_target_step = RESET_STEP_ZERO;
 701   3      
 702   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 703   3                              }
 704   2                              else
 705   2                              {
 706   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 707   3                                      {
 708   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;
 709   4                                      }
 710   3                              }
 711   2                              break;  
 712   2                      case WORKMODULE_BLOW:
 713   2                      case WORKMODULE_WARM:
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 13  

 714   2                              if((p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S)
 715   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))
 716   2                              {
 717   3                                      if(RESET == p_data->remote.keyctrl.keystate_enter_swing)
 718   3                                      {
 719   4                                              s_step = STEP1;
 720   4                                              p_data->remote.keyctrl.keystate_enter_swing = SET;
 721   4                                              p_data->motor.blow_target_step     = TARGET_STEP_BLOW;
 722   4                                              p_data->motor.blow_motor_step_pri  = TARGET_STEP_BLOW;
 723   4                                              p_data->motor.blow_target_step_pri = TARGET_LOW_SWING;
 724   4                                      }
 725   3                                      else
 726   3                                      {
 727   4                                              if(ON == p_data->remote.keyctrl.keystate_swing)
 728   4                                              {
 729   5                                                      switch(s_step)
 730   5                                                      {
 731   6                                                              case STEP1:
 732   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 733   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 734   6                                                                      {
 735   7                                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 736   7                                                                              s_step = STEP2;
 737   7                                                                      }
 738   6                                                                      break;
 739   6                                                              case STEP2:
 740   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 741   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 742   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 743   6                                                                      {
 744   7                                                                              s_step = STEP3;
 745   7                                                                      }
 746   6                                                                      break;
 747   6                                                              case STEP3:
 748   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 749   6                                                                      if(p_data->motor.blow_motor_step == TARGET_HIGH_SWING)
 750   6                                                                      {
 751   7                                                                              p_data->motor.blow_target_step          = TARGET_LOW_SWING;
 752   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;             ///< save target step
 753   7                                                                      }
 754   6                                                                      else if(p_data->motor.blow_motor_step == TARGET_LOW_SWING)
 755   6                                                                      {
 756   7                                                                              p_data->motor.blow_target_step          = TARGET_HIGH_SWING;
 757   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_HIGH_SWING;    ///< save target step
 758   7                                                                      }
 759   6                                                                      else
 760   6                                                                      {
 761   7                                                                              if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 762   7                                                                              {
 763   8                                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 764   8                                                                              }
 765   7                                                                      }
 766   6                                                                      break;
 767   6                                                              default:
 768   6                                                                      break;
 769   6                                                      }
 770   5                                              }
 771   4                                              else
 772   4                                              {
 773   5                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 774   5                                              }
 775   4                                              p_data->motor.absorb_target_step = RESET_STEP_ZERO;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 14  

 776   4      
 777   4                                              if(YES == MOTOR_CHK_MOVE_TO_TARGET)
 778   4                                              {
 779   5                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 780   5                                              }
 781   4                                      }
 782   3                              }
 783   2                              break;
 784   2                      case WORKMODULE_ABSORB:
 785   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 786   2                              {
 787   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 788   3                                      p_data->motor.absorb_target_step = TARGET_STEP_ABSORB;
 789   3      
 790   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 791   3                              }
 792   2                              else
 793   2                              {
 794   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 795   3                                      {
 796   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;    
 797   4                                      }
 798   3                              }
 799   2                              break;
 800   2                      default:
 801   2                              break;
 802   2              }
 803   1      }
 804          
 805          /*********************************************************************************************************
             -**************
 806          * Function Name: 
 807          * Description  : 
 808          * Arguments    : None
 809          * Return Value : None
 810          **********************************************************************************************************
             -*************/
 811          void fml_ctrl_deal_fan(datall* p_data)
 812          {
 813   1              switch(p_data->remote.workmode.workmode_current)
 814   1              {
 815   2                      case WORKMODULE_STANDBY:
 816   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 817   2                              {
 818   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 819   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 820   3                              }
 821   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 822   2                              break;
 823   2                      case WORKMODULE_BLOW:
 824   2                      case WORKMODULE_WARM:
 825   2                              if((ON == p_data->remote.keyctrl.keystate_move_target) ///< move to target step.
 826   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))  ///< need open blow fan when work swing func.
 827   2                              {
 828   3                                      p_data->remote.workmode.flag_workdelay_1s = SET;
 829   3                                      p_data->remote.keyctrl.keystate_fan_blow  = ON;
 830   3                              }
 831   2                              else
 832   2                              {
 833   3                                      if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 834   3                                      {
 835   4                                              p_data->remote.workmode.flag_workdelay_1s       = RESET;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 15  

 836   4                                              p_data->remote.keyctrl.keystate_move_target = OFF;
 837   4                                              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 838   4                                      }                                                               
 839   3                              }
 840   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 841   2                              break;
 842   2                      case WORKMODULE_ABSORB:
 843   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 844   2                              {
 845   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 846   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 847   3                                              if(YES == MOTOR_CHK_MOVE_TO_TARGET)
 848   3                                              {
 849   4                                                      p_data->remote.keyctrl.keystate_fan_absorb      = ON;
 850   4                                              }
 851   3                              }
 852   2                              break;
 853   2                      default:
 854   2                              break;
 855   2              }
 856   1      }
 857          
 858          /*********************************************************************************************************
             -**************
 859          * Function Name: 
 860          * Description  : 
 861          * Arguments    : None
 862          * Return Value : None
 863          **********************************************************************************************************
             -*************/
 864          void fml_ctrl_deal_swing(datall* p_data)
 865          {
 866   1              switch(p_data->remote.workmode.workmode_current)
 867   1              {
 868   2                      case WORKMODULE_STANDBY:
 869   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 870   2                              p_data->remote.keyctrl.keystate_swing      = OFF;
 871   2                              break;
 872   2                      case WORKMODULE_BLOW:
 873   2                      case WORKMODULE_WARM:
 874   2                              if(p_data->remote.keyctrl.keystate_swing_pri != p_data->remote.keyctrl.keystate_swing)
 875   2                              {
 876   3                                      p_data->remote.keyctrl.keystate_swing_pri = p_data->remote.keyctrl.keystate_swing;
 877   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)                                         //?
 878   3                                      {
 879   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 880   4                                      }
 881   3                                      p_data->remote.keyctrl.keystate_enter_swing = SET;
 882   3                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;     ///< move to last step
 883   3                              }
 884   2                              else
 885   2                              {
 886   3                                      if((ON == p_data->remote.keyctrl.keystate_swing)                                ///< open swing func
 887   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))         ///< move to target step
 888   3                                      {
 889   4                                              p_data->remote.keyctrl.keystate_open_swing = ON;
 890   4                                      }
 891   3                                      else
 892   3                                      {
 893   4                                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 894   4                                      }
 895   3                              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 16  

 896   2                              break;
 897   2                      case WORKMODULE_ABSORB:
 898   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 899   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 900   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 901   2                              {
 902   3                                      p_data->remote.keyctrl.keystate_swing      = OFF;
 903   3                              }
 904   2                              break;
 905   2                      default:
 906   2                              break;
 907   2              }
 908   1      }
 909          
 910          /*********************************************************************************************************
             -**************
 911          * Function Name: 
 912          * Description  : 
 913          * Arguments    : None
 914          * Return Value : None
 915          **********************************************************************************************************
             -*************/
 916          void fml_ctrl_deal_timer(datall* p_data)
 917          {
 918   1              if(REMOTE != p_data->keytype)
 919   1                      return;
 920   1              
 921   1              hal_timer_mode_deal(&p_data->remote.workmode);
 922   1      }
 923          /*********************************************************************************************************
             -**************
 924          * Function Name: 
 925          * Description  : 
 926          * Arguments    : None
 927          * Return Value : None
 928          **********************************************************************************************************
             -*************/
 929          void fml_ctrl_key_logic(datall* p_data)
 930          {
 931   1              #ifdef XY_SYS_TEST_MODE
 932   1                      if(YES == p_data->testmode)
 933   1                              return;
 934   1              #endif
 935   1              
 936   1              fml_ctrl_recv_display(p_data);                                                  ///< recive remote key value
 937   1              if(REMOTE != p_data->keytype)
 938   1                      return;
 939   1      
 940   1              fml_ctrl_deal_key(p_data);                                                              ///< analysis key value 
 941   1              fml_ctrl_deal_mode(p_data);                                                             ///< control relay by diff mode
 942   1              fml_ctrl_deal_motor(p_data);                                                    ///< update motor step
 943   1              fml_ctrl_deal_swing(p_data);                                                    ///< control swing func
 944   1              fml_ctrl_deal_fan(p_data);                                                              ///< control fan machine
 945   1              fml_ctrl_chk_error(p_data);                                                             ///< check data result legal
 946   1      }
 947          
 948          /*********************************************************************************************************
             -**************
 949          * Function Name: 
 950          * Description  : 
 951          * Arguments    : None
 952          * Return Value : None
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 17  

 953          **********************************************************************************************************
             -*************/
 954          void fml_ctrl_work_time(datall* p_data)
 955          {
 956   1              static workmodule  s_workmode = WORKMODULE_STANDBY;
 957   1              static unsigned int  s_work_min = 0;
 958   1      
 959   1              if(REMOTE != p_data->keytype)
 960   1                      return;
 961   1              
 962   1              if(s_workmode != p_data->remote.workmode.workmode_current)
 963   1              {
 964   2                      s_workmode = p_data->remote.workmode.workmode_current;
 965   2                      s_work_min = 0;
 966   2              }       
 967   1              switch(p_data->remote.workmode.workmode_current)
 968   1              {
 969   2                      case WORKMODULE_STANDBY:
 970   2                              s_work_min = 0;
 971   2                              break;
 972   2                      case WORKMODULE_BLOW:
 973   2                      case WORKMODULE_WARM:
 974   2                      case WORKMODULE_ABSORB:
 975   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 976   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 977   2                              {
 978   3                                      s_work_min++;
 979   3                              }
 980   2                              break;
 981   2                      default:
 982   2                              break;
 983   2              }       
 984   1              if(s_work_min >= CLOCK_WORKTIME_120MIN)
 985   1              {
 986   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 987   2              }
 988   1      }
 989          
 990          /*********************************************************************************************************
             -**************
 991          * Function Name: 
 992          * Description  : 
 993          * Arguments    : None
 994          * Return Value : None
 995          **********************************************************************************************************
             -*************/
 996          void fml_ctrl_deal_alarm(datall* p_data)
 997          {
 998   1              if((p_data->temperature.value >= ALARM_HIGH_TEMP))
 999   1              {
1000   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
1001   2              }
1002   1      }
1003          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4695    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =     22      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/17/2021 13:19:57 PAGE 18  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
