C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE XY_FML_CTRL
OBJECT MODULE PLACED IN .\Objects\xy_fml_ctrl.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE 02_FML\xy_fml_ctrl.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\01_APL;.\
                    -02_FML;.\03_HAL;.\04_SYS) DEBUG PRINT(.\Listings\xy_fml_ctrl.lst) OBJECT(.\Objects\xy_fml_ctrl.obj)

line level    source

   1          #include "xy_sys_headfile.h"
   2          
   3          /*********************************************************************************************************
             -**************
   4          * Function Name: 
   5          * Description  : 
   6          * Arguments    : None
   7          * Return Value : None
   8          **********************************************************************************************************
             -*************/
   9          void fml_ctrl_init_reg(void)
  10          {
  11   1              hal_port_init();
  12   1              hal_timer_Init();
  13   1              hal_serial_Init();
  14   1      }
  15          
  16          /*********************************************************************************************************
             -**************
  17          * Function Name: 
  18          * Description  : 
  19          * Arguments    : None
  20          * Return Value : None
  21          **********************************************************************************************************
             -*************/
  22          void fml_ctrl_init_data(datall* p_data)
  23          {
  24   1              p_data->remote.workmode.workmode_current        = WORKMODULE_DEFAULT;
  25   1              p_data->remote.keyctrl.keystate_light           = OFF;
  26   1              p_data->remote.keyctrl.keystate_swing           = OFF;
  27   1              p_data->remote.keyctrl.keystate_ptc             = OFF;
  28   1              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
  29   1              p_data->remote.keyctrl.keystate_fan_absorb      = OFF;
  30   1              p_data->remote.keyctrl.keystate_ptc_wait        = OFF;
  31   1      
  32   1              p_data->remote.keyctrl.keystate_swing_pri       = OFF;
  33   1              p_data->remote.keyctrl.keystate_enter_swing = RESET;
  34   1      
  35   1              p_data->remote.workmode.flag_workdelay_1s       = SET;
  36   1              p_data->remote.workmode.flag_workdelay_10s      = SET;
  37   1              p_data->remote.workmode.workdelay_1s            = CLOCK_DELAYTIMER_0S;
  38   1              p_data->remote.workmode.workdelay_10s           = CLOCK_DELAYTIMER_10S;
  39   1      
  40   1              p_data->remote.workmode.flag_work_colddry       = NO;
  41   1              p_data->remote.workmode.flag_work_warmdry       = NO;
  42   1      
  43   1              p_data->uart.send_data                                          = 0;
  44   1              p_data->display.disp_icon_data                          = 0;
  45   1      }
  46          
  47          /*********************************************************************************************************
             -**************
  48          * Function Name: 
  49          * Description  : 
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 2   

  50          * Arguments    : None
  51          * Return Value : None
  52          **********************************************************************************************************
             -*************/
  53          void fml_ctrl_chk_error(datall* p_data)
  54          {
  55   1              datacommon       err;
  56   1              unsigned int motor[2] = {0};
  57   1              switchstate  state[3] = {0};
  58   1      
  59   1              motor[0] = p_data->motor.blow_target_step;
  60   1              motor[1] = p_data->motor.blow_motor_step;
  61   1              state[0] = p_data->remote.keyctrl.keystate_fan_blow;
  62   1              state[1] = p_data->remote.keyctrl.keystate_fan_absorb;
  63   1              state[2] = p_data->remote.keyctrl.keystate_ptc;
  64   1              err.dat  = 0;
  65   1      
  66   1              if(YES == CTRL_CHECK_ERROR_NUMB_1(motor[0], motor[1], state[0], state[1], state[2]))
  67   1              {
  68   2                      p_data->motor.blow_target_step = RESET_STEP_ZERO;
  69   2                      err.bits.b0 = 1;
  70   2              }
  71   1      
  72   1              if(YES == CTRL_CHECK_ERROR_NUMB_2(motor[0], motor[1], state[0], state[1], state[2]))
  73   1              {
  74   2                      p_data->remote.keyctrl.keystate_fan_blow = OFF;
  75   2                      err.bits.b1 = 1;
  76   2              }
  77   1      
  78   1              if(YES == CTRL_CHECK_ERROR_NUMB_3(motor[0], motor[1], state[0], state[1], state[2]))
  79   1              {
  80   2                      if(p_data->motor.blow_motor_step && (NO == MOTOR_CHK_STEP_IS_LEGAL(p_data->motor.blow_motor_step)))
  81   2                      {
  82   3                              p_data->remote.keyctrl.keystate_open_swing = OFF;
  83   3                      }
  84   2      
  85   2                      if(OFF == p_data->remote.keyctrl.keystate_open_swing)
  86   2                      {
  87   3                              p_data->remote.keyctrl.keystate_fan_blow = OFF;
  88   3                              err.bits.b2 = 1;        
  89   3                      }
  90   2              }
  91   1              
  92   1              if(YES == CTRL_CHECK_ERROR_NUMB_4(motor[0], motor[1], state[0], state[1], state[2]))
  93   1              {
  94   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
  95   2                      err.bits.b3 = 1;
  96   2              }
  97   1              
  98   1              if(YES == CTRL_CHECK_ERROR_NUMB_5(motor[0], motor[1], state[0], state[1], state[2]))
  99   1              {
 100   2                      p_data->remote.keyctrl.keystate_fan_absorb = OFF;
 101   2                      err.bits.b4 = 1;
 102   2              }
 103   1      
 104   1              if(YES == CTRL_CHECK_ERROR_NUMB_6(motor[0], motor[1], state[0], state[1], state[2]))
 105   1              {
 106   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
 107   2                      err.bits.b5 = 1;
 108   2              }
 109   1              
 110   1              p_data->error.dat = err.dat;    
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 3   

 111   1      }
 112          
 113          /*********************************************************************************************************
             -**************
 114          * Function Name: 
 115          * Description  : 
 116          * Arguments    : None
 117          * Return Value : None
 118          **********************************************************************************************************
             -*************/
 119          void fml_ctrl_icon_display(datall* p_data)
 120          {       
 121   1              #ifdef XY_SYS_TEST_MODE
 122   1                      if(YES == p_data->testmode)
 123   1                              return;
 124   1              #endif
 125   1              
 126   1              if(REMOTE != p_data->keytype)
 127   1                      return;
 128   1              
 129   1              switch(p_data->remote.workmode.workmode_current)
 130   1              {
 131   2                      case WORKMODULE_STANDBY:
 132   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)                //workdelay!
 133   2                              {
 134   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_STANDBY;
 135   3                              }
 136   2                              else
 137   2                              {
 138   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 139   3                              }
 140   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 141   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 142   2                              break;
 143   2                      case WORKMODULE_BLOW:
 144   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;
 145   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 146   2                              p_data->display.disp_icon_blow      = SYM_BLOW_ON;
 147   2                              break;
 148   2                      case WORKMODULE_WARM:
 149   2                              p_data->display.disp_icon_warm      = SYM_WARM_ON;
 150   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 151   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 152   2                              break;
 153   2                      case WORKMODULE_ABSORB:
 154   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)
 155   2                              {
 156   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_ABSORB;
 157   3                              }
 158   2                              else
 159   2                              {
 160   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 161   3                              }       
 162   2                              p_data->display.disp_icon_absorb  = SYM_ABSORB_ON;
 163   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 164   2                              break;
 165   2                      default:
 166   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;                              
 167   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 168   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 169   2                              break;
 170   2              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 4   

 171   1      }
 172          
 173          /*********************************************************************************************************
             -**************
 174          * Function Name: 
 175          * Description  : 
 176          * Arguments    : None
 177          * Return Value : None
 178          **********************************************************************************************************
             -*************/
 179          void fml_ctrl_recv_old_version(datall* p_data)
 180          {
 181   1              unsigned char i;
 182   1              unsigned char temp_sum = 0;
 183   1              unsigned char buffer[sizeof(p_data->uart.rec_uart1_dat)] = {0};
 184   1      
 185   1              memcpy(buffer, p_data->uart.rec_uart1_dat, sizeof(buffer));
 186   1              memset(p_data->uart.rec_uart1_dat, 0, sizeof(buffer));
 187   1      
 188   1              for(i=0; i<5; i++)
 189   1              {
 190   2                      temp_sum += buffer[i];
 191   2              }
 192   1      
 193   1              if(temp_sum == buffer[i])                       ///< check data 
 194   1              {
 195   2                      p_data->remote.key.keyremote.dat = buffer[2] + (buffer[3]<<8);
 196   2      
 197   2                      if(p_data->remote.key.keyremote.bits.b0)
 198   2                      {
 199   3                              p_data->remote.key.keysta = KEY_LIGHT;
 200   3                      }
 201   2                      else if(p_data->remote.key.keyremote.bits.b1)
 202   2                      {
 203   3                              p_data->remote.key.keysta = KEY_BLOW;
 204   3                      }
 205   2                      else if(p_data->remote.key.keyremote.bits.b2)
 206   2                      {
 207   3                              p_data->remote.key.keysta = KEY_ABSORB;
 208   3                      }
 209   2                      else if(p_data->remote.key.keyremote.bits.b3)
 210   2                      {
 211   3                              p_data->remote.key.keysta = KEY_WARM;
 212   3                      }
 213   2                      else if(p_data->remote.key.keyremote.bits.b4)
 214   2                      {
 215   3                              p_data->remote.key.keysta = KEY_SWING;
 216   3                      }
 217   2                      else if(p_data->remote.key.keyremote.bits.b5)
 218   2                      {
 219   3                              p_data->remote.key.keysta = KEY_RAV;
 220   3                      }
 221   2                      else if(p_data->remote.key.keyremote.bits.b6)
 222   2                      {
 223   3                              p_data->remote.key.keysta = KEY_COLD_DRY;
 224   3                      }
 225   2                      else if(p_data->remote.key.keyremote.bits.b7)
 226   2                      {
 227   3                              p_data->remote.key.keysta = KEY_STANDBY;
 228   3                      }
 229   2                      else if(p_data->remote.key.keyremote.bits.b8)
 230   2                      {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 5   

 231   3                              p_data->remote.key.keysta = KEY_WARM_DRY;
 232   3                      }
 233   2      
 234   2                      if(KEY_RELEASE != p_data->remote.key.keysta)
 235   2                      {
 236   3                              if(TOUCH == p_data->keytype)
 237   3                              {
 238   4                                      memset(&p_data->touch, 0, sizeof(p_data->touch));
 239   4                                      fml_ctrl_init_data(p_data);
 240   4                                      p_data->keytype = REMOTE;
 241   4                              }
 242   3                      }
 243   2      
 244   2                      p_data->temperature.value = buffer[4];
 245   2              }
 246   1      }
 247          
 248          /*********************************************************************************************************
             -**************
 249          * Function Name: 
 250          * Description  : 
 251          * Arguments    : None
 252          * Return Value : None
 253          **********************************************************************************************************
             -*************/
 254          void fml_ctrl_recv_display(datall* p_data)
 255          {
 256   1              if(p_data->uart.rec_uart1_ok)
 257   1              {
 258   2                      p_data->uart.rec_uart1_ok = 0;
 259   2                      fml_ctrl_recv_old_version(p_data);                      ///< old version(only use remote key)
 260   2              }
 261   1      }
 262          
 263          /*********************************************************************************************************
             -**************
 264          * Function Name: 
 265          * Description  : 
 266          * Arguments    : None
 267          * Return Value : None
 268          **********************************************************************************************************
             -*************/
 269          void fml_ctrl_deal_key(datall* p_data)
 270          {       
 271   1              switch(p_data->remote.key.keysta)
 272   1              {
 273   2                      case KEY_STANDBY:
 274   2                              if(KEY_STANDBY != p_data->remote.key.keysta_pri)
 275   2                              {
 276   3                                      p_data->remote.key.keysta_pri = KEY_STANDBY;
 277   3      
 278   3                                      p_data->buzzer.normal_bee_on = ON;
 279   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 280   3      
 281   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 282   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 283   3                              }
 284   2                              else
 285   2                              {
 286   3                                      p_data->buzzer.burn_bee_on = ON;
 287   3                              }
 288   2                              break;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 6   

 289   2                      case KEY_BLOW:
 290   2                              if(KEY_BLOW != p_data->remote.key.keysta_pri)
 291   2                              {
 292   3                                      p_data->remote.key.keysta_pri = KEY_BLOW;
 293   3      
 294   3                                      p_data->buzzer.normal_bee_on = ON;
 295   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_BLOW;
 296   3      
 297   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 298   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 299   3                              }
 300   2                              else
 301   2                              {
 302   3                                      p_data->buzzer.burn_bee_on = ON;
 303   3                              }
 304   2                              break;
 305   2                      case KEY_ABSORB:
 306   2                              if(KEY_ABSORB != p_data->remote.key.keysta_pri)
 307   2                              {
 308   3                                      p_data->remote.key.keysta_pri = KEY_ABSORB;
 309   3                                      
 310   3                                      p_data->buzzer.normal_bee_on = ON;
 311   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_ABSORB;
 312   3      
 313   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 314   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 315   3                              }
 316   2                              else
 317   2                              {
 318   3                                      p_data->buzzer.burn_bee_on = ON;
 319   3                              }
 320   2                              break;
 321   2                      case KEY_WARM:
 322   2                              if(KEY_WARM != p_data->remote.key.keysta_pri)                                   
 323   2                              {
 324   3                                      p_data->remote.key.keysta_pri = KEY_WARM;
 325   3      
 326   3                                      p_data->buzzer.normal_bee_on = ON;
 327   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_WARM;
 328   3      
 329   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 330   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 331   3                              }
 332   2                              else
 333   2                              {
 334   3                                      p_data->buzzer.burn_bee_on = ON;
 335   3                              }
 336   2                              break;
 337   2                      case KEY_COLD_DRY:
 338   2                              if(KEY_COLD_DRY != p_data->remote.key.keysta_pri)
 339   2                              {
 340   3                                      p_data->remote.key.keysta_pri = KEY_COLD_DRY;
 341   3                                      
 342   3                                      p_data->buzzer.normal_bee_on = ON;
 343   3                                      //p_data->remote.workmode.workmode_cur = WORKMODULE_BLOW;
 344   3      
 345   3                                      p_data->remote.workmode.flag_work_colddry = YES;
 346   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 347   3                              }
 348   2                              else
 349   2                              {
 350   3                                      p_data->buzzer.burn_bee_on = ON;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 7   

 351   3                              }
 352   2                              break;
 353   2                      case KEY_WARM_DRY:
 354   2                              if(KEY_WARM_DRY != p_data->remote.key.keysta_pri)
 355   2                              {
 356   3                                      p_data->remote.key.keysta_pri = KEY_WARM_DRY;
 357   3                                      
 358   3                                      p_data->buzzer.normal_bee_on = ON;
 359   3                                      //p_data->remote.workmode.workmode_cur = WORKMODULE_WARM;
 360   3                                      
 361   3                                      p_data->remote.workmode.flag_work_warmdry = YES;
 362   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 363   3                              }
 364   2                              else
 365   2                              {
 366   3                                      p_data->buzzer.burn_bee_on = ON;
 367   3                              }
 368   2                              break;
 369   2                      case KEY_SWING:
 370   2                              /* only blow mode or warm mode and dry can enter this condition */
 371   2                              if(((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 372   2                                      || (WORKMODULE_WARM == p_data->remote.workmode.workmode_current)))
 373   2                              {
 374   3                                      p_data->buzzer.normal_bee_on = ON;
 375   3                                      if(OFF == p_data->remote.keyctrl.keystate_swing)
 376   3                                      {
 377   4                                              /* open swing page */
 378   4                                              p_data->remote.keyctrl.keystate_swing = ON;
 379   4                                      }
 380   3                                      else
 381   3                                      {
 382   4                                              /* close swing page */
 383   4                                              p_data->remote.keyctrl.keystate_swing = OFF;
 384   4                                      }
 385   3                              }
 386   2                              else
 387   2                              {
 388   3                                      p_data->buzzer.burn_bee_on = ON;
 389   3                              }
 390   2                              break;
 391   2                      case KEY_LIGHT:
 392   2                              p_data->buzzer.normal_bee_on = ON;
 393   2                              if(OFF == p_data->remote.keyctrl.keystate_light)
 394   2                              {
 395   3                                      p_data->remote.keyctrl.keystate_light = ON;
 396   3                              }
 397   2                              else
 398   2                              {
 399   3                                      p_data->remote.keyctrl.keystate_light = OFF;
 400   3                              }
 401   2                              break;
 402   2                      default:
 403   2                              break;
 404   2              }
 405   1              p_data->remote.key.keysta = KEY_RELEASE;
 406   1      }
 407          
 408          /*********************************************************************************************************
             -**************
 409          * Function Name: 
 410          * Description  : 
 411          * Arguments    : None
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 8   

 412          * Return Value : None
 413          **********************************************************************************************************
             -*************/
 414          void fml_ctrl_deal_automode(workmoduleflag* p_mode)                                                     //check
 415          {
 416   1              static switchstate       s_onetime  = RESET;
 417   1              static unsigned char s_time_dry_tmp = 0;
 418   1              static unsigned int  s_time_dry_min = 0;
 419   1              static switchstate       s_state    = RESET;
 420   1      
 421   1              if((YES == p_mode->flag_work_warmdry) || (YES == p_mode->flag_work_colddry))
 422   1              {
 423   2                      if(YES == p_mode->flag_work_warmdry)
 424   2                      {
 425   3                              if(WARM != s_state)
 426   3                              {
 427   4                                      s_onetime = RESET;
 428   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 429   4                              }
 430   3                              s_state = WARM;
 431   3                      }
 432   2                      else
 433   2                      {
 434   3                              if(COLD != s_state)
 435   3                              {
 436   4                                      s_onetime = RESET;
 437   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 438   4                              }
 439   3                              s_state = COLD;
 440   3                      }
 441   2                      if(YES == p_mode->flag_work_warmdry)
 442   2                      {
 443   3                              if((s_time_dry_min % (CLOCK_WARMDRY_WARM_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 444   3                                      < (CLOCK_WARMDRY_WARM_10MIN - CLOCK_DELAYTIMER_10S))
 445   3                              {
 446   4                                      p_mode->workmode_current = WORKMODULE_WARM;
 447   4                              }
 448   3                              else
 449   3                              {
 450   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 451   4                              }
 452   3                      }
 453   2                      else
 454   2                      {
 455   3                              if((s_time_dry_min % (CLOCK_COLDDRY_COLD_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 456   3                                      < CLOCK_COLDDRY_COLD_10MIN)
 457   3                              {
 458   4                                      p_mode->workmode_current = WORKMODULE_BLOW;
 459   4                              }
 460   3                              else
 461   3                              {
 462   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 463   4                              }
 464   3                      }               
 465   2                      if(RESET == s_onetime)
 466   2                      {
 467   3                              s_onetime = SET;
 468   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 469   3                      }
 470   2                      if(YES == CTRL_EXCEED_DELAY_TIMER(1, p_mode->workdelay_cyc, s_time_dry_tmp))
 471   2                      {
 472   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 9   

 473   3                              s_time_dry_min++;
 474   3                              if(s_time_dry_min >= CLOCK_WORKDRY_ALL_60MIN)
 475   3                              {
 476   4                                      p_mode->workmode_current = WORKMODULE_STANDBY;
 477   4                                      if(YES == p_mode->flag_work_warmdry)
 478   4                                      {       
 479   5                                              p_mode->flag_work_warmdry = NO;
 480   5                                      }
 481   4                                      else
 482   4                                      {
 483   5                                              p_mode->flag_work_colddry = NO;
 484   5                                      }
 485   4                              }
 486   3                      }
 487   2              }
 488   1              else
 489   1              {
 490   2                      s_state = RESET;
 491   2              }
 492   1      }
 493          
 494          /*********************************************************************************************************
             -**************
 495          * Function Name: 
 496          * Description  : 
 497          * Arguments    : None
 498          * Return Value : None
 499          **********************************************************************************************************
             -*************/
 500          void fml_ctrl_deal_mode(datall* p_data)
 501          {       
 502   1              static switchstate   s_onetime[2] = {STEP1, RESET};
 503   1              static unsigned char s_timecount_cur = 0, s_timecount_pri = 0;
 504   1              static unsigned char s_time_ptc_worktime = 0;
 505   1      
 506   1              fml_ctrl_deal_automode(&p_data->remote.workmode);
 507   1              switch(p_data->remote.workmode.workmode_current)
 508   1              {
 509   2                      case WORKMODULE_STANDBY:
 510   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 511   2                              {
 512   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 513   3                              }
 514   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 515   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 516   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 517   2                              p_data->remote.key.keysta_pri = KEY_STANDBY;
 518   2                              break;
 519   2                      case WORKMODULE_BLOW:
 520   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 521   2                              {
 522   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 523   3                              }
 524   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 525   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 526   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 527   2                              break;
 528   2                      case WORKMODULE_WARM:
 529   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)       ///< delay 10s
 530   2                              {
 531   3                                      if(ON == p_data->remote.keyctrl.keystate_move_target)                   ///< move target step
 532   3                                      {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 10  

 533   4                                              if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
 534   4                                              {
 535   5                                                      p_data->remote.workmode.flag_workdelay_1s = RESET;
 536   5                                                      p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 537   5                                              }                                       
 538   4                                              p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 539   4                                      }
 540   3                                      else
 541   3                                      {
 542   4                                              p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;             ///< start from last step
 543   4                                      }
 544   3                              }
 545   2                              else
 546   2                              {
 547   3                                      if(STEP3 == s_onetime[0])
 548   3                                      {
 549   4                                              if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
 550   4                                              {
 551   5                                                      if(NO == CTRL_EXCEED_DELAY_TIMER(10, s_timecount_cur, s_timecount_pri))
 552   5                                                      {
 553   6                                                              p_data->remote.workmode.flag_workdelay_1s = SET;
 554   6                                                              p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 555   6                                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 556   6                                                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 557   6                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 558   6                                                      }
 559   5                                              }
 560   4                                      }
 561   3                              }               
 562   2                              if(p_data->remote.workmode.workdelay_1s >= CLOCK_DELAYTIMER_1S)
 563   2                              {
 564   3                                      if((OFF == p_data->remote.keyctrl.keystate_ptc_wait) 
 565   3                              //              && (YES == MOTOR_CHK_MOVE_TO_TARGET))
 566   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))
 567   3                                      {
 568   4                                              p_data->remote.keyctrl.keystate_ptc   = ON;                     ///< restart ptc
 569   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 570   4                                      }
 571   3                              }
 572   2                              break;
 573   2                      case WORKMODULE_ABSORB:
 574   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 575   2                              {
 576   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 577   3                              }
 578   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 579   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 580   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 581   2                              break;
 582   2                      default:
 583   2                              break;
 584   2              }
 585   1              if(p_data->remote.keyctrl.keystate_ptc_pri != p_data->remote.keyctrl.keystate_ptc)
 586   1              {
 587   2                      if(ON == p_data->remote.keyctrl.keystate_ptc)
 588   2                      {
 589   3                              if(RESET == s_onetime[1])
 590   3                              {
 591   4                                      s_time_ptc_worktime = p_data->remote.workmode.workdelay_cyc;
 592   4                              }
 593   3                              s_onetime[1] = SET;
 594   3                      }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 11  

 595   2                      else
 596   2                      {
 597   3                              s_onetime[1] = RESET;
 598   3                      }
 599   2                      p_data->remote.keyctrl.keystate_ptc_pri = p_data->remote.keyctrl.keystate_ptc;  
 600   2              }
 601   1              else
 602   1              {
 603   2                      if(ON == p_data->remote.keyctrl.keystate_ptc_pri)
 604   2                      {
 605   3                              if(YES == CTRL_EXCEED_DELAY_TIMER(0, p_data->remote.workmode.workdelay_cyc, s_time_ptc_worktime))
 606   3                              {
 607   4                                      p_data->remote.keyctrl.keystate_ptc_delay = YES;
 608   4                              }
 609   3                      }
 610   2                      else
 611   2                      {
 612   3                              p_data->remote.keyctrl.keystate_ptc_delay = NO;
 613   3                      }
 614   2              }
 615   1      }
 616          
 617          /*********************************************************************************************************
             -**************
 618          * Function Name: 
 619          * Description  : 
 620          * Arguments    : None
 621          * Return Value : None
 622          **********************************************************************************************************
             -*************/
 623          void fml_ctrl_deal_motor(datall* p_data)
 624          {
 625   1              static switchstate s_step = STEP1;
 626   1      
 627   1              switch(p_data->remote.workmode.workmode_current)
 628   1              {
 629   2                      case WORKMODULE_STANDBY:
 630   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 631   2                              {
 632   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 633   3      
 634   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 635   3                              }
 636   2                              else
 637   2                              {
 638   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 639   3                                      {
 640   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;
 641   4                                      }
 642   3                              }
 643   2                              break;  
 644   2                      case WORKMODULE_BLOW:
 645   2                      case WORKMODULE_WARM:
 646   2                              if((p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S)
 647   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))
 648   2                              {
 649   3                                      if(RESET == p_data->remote.keyctrl.keystate_enter_swing)
 650   3                                      {
 651   4                                              s_step = STEP1;
 652   4                                              p_data->remote.keyctrl.keystate_enter_swing = SET;
 653   4                                              p_data->motor.blow_target_step     = TARGET_STEP_BLOW;
 654   4                                              p_data->motor.blow_motor_step_pri  = TARGET_STEP_BLOW;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 12  

 655   4                                              p_data->motor.blow_target_step_pri = TARGET_LOW_SWING;
 656   4                                      }
 657   3                                      else
 658   3                                      {
 659   4                                              if(ON == p_data->remote.keyctrl.keystate_swing)
 660   4                                              {
 661   5                                                      switch(s_step)
 662   5                                                      {
 663   6                                                              case STEP1:
 664   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 665   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 666   6                                                                      {
 667   7                                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 668   7                                                                              s_step = STEP2;
 669   7                                                                      }
 670   6                                                                      break;
 671   6                                                              case STEP2:
 672   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 673   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 674   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 675   6                                                                      {
 676   7                                                                              s_step = STEP3;
 677   7                                                                      }
 678   6                                                                      break;
 679   6                                                              case STEP3:
 680   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 681   6                                                                      if(p_data->motor.blow_motor_step == TARGET_HIGH_SWING)
 682   6                                                                      {
 683   7                                                                              p_data->motor.blow_target_step          = TARGET_LOW_SWING;
 684   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;             ///< save target step
 685   7                                                                      }
 686   6                                                                      else if(p_data->motor.blow_motor_step == TARGET_LOW_SWING)
 687   6                                                                      {
 688   7                                                                              p_data->motor.blow_target_step          = TARGET_HIGH_SWING;
 689   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_HIGH_SWING;    ///< save target step
 690   7                                                                      }
 691   6                                                                      else
 692   6                                                                      {
 693   7                                                                              if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 694   7                                                                              {
 695   8                                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 696   8                                                                              }
 697   7                                                                      }
 698   6                                                                      break;
 699   6                                                              default:
 700   6                                                                      break;
 701   6                                                      }
 702   5                                              }
 703   4                                              else
 704   4                                              {
 705   5                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 706   5                                              }
 707   4      
 708   4                                              if(YES == MOTOR_CHK_MOVE_TO_TARGET)
 709   4                                              {
 710   5                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 711   5                                              }
 712   4                                      }
 713   3                              }
 714   2                              break;
 715   2                      case WORKMODULE_ABSORB:
 716   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 13  

 717   2                              {
 718   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 719   3      
 720   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 721   3                              }
 722   2                              else
 723   2                              {
 724   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 725   3                                      {
 726   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;    
 727   4                                      }
 728   3                              }
 729   2                              break;
 730   2                      default:
 731   2                              break;
 732   2              }
 733   1      }
 734          
 735          /*********************************************************************************************************
             -**************
 736          * Function Name: 
 737          * Description  : 
 738          * Arguments    : None
 739          * Return Value : None
 740          **********************************************************************************************************
             -*************/
 741          void fml_ctrl_deal_fan(datall* p_data)
 742          {
 743   1              switch(p_data->remote.workmode.workmode_current)
 744   1              {
 745   2                      case WORKMODULE_STANDBY:
 746   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 747   2                              {
 748   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 749   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 750   3                              }
 751   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 752   2                              break;
 753   2                      case WORKMODULE_BLOW:
 754   2                      case WORKMODULE_WARM:
 755   2                              if((ON == p_data->remote.keyctrl.keystate_move_target) ///< move to target step.
 756   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))  ///< need open blow fan when work swing func.
 757   2                              {
 758   3                                      p_data->remote.workmode.flag_workdelay_1s = SET;
 759   3                                      p_data->remote.keyctrl.keystate_fan_blow  = ON;
 760   3                              }
 761   2                              else
 762   2                              {
 763   3                                      if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 764   3                                      {
 765   4                                              p_data->remote.workmode.flag_workdelay_1s       = RESET;
 766   4                                              p_data->remote.keyctrl.keystate_move_target = OFF;
 767   4                                              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 768   4                                      }                                                               
 769   3                              }
 770   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 771   2                              break;
 772   2                      case WORKMODULE_ABSORB:
 773   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 774   2                              {
 775   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 776   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 14  

 777   3                                      p_data->remote.keyctrl.keystate_fan_absorb      = ON;
 778   3                              }
 779   2                              break;
 780   2                      default:
 781   2                              break;
 782   2              }
 783   1      }
 784          
 785          /*********************************************************************************************************
             -**************
 786          * Function Name: 
 787          * Description  : 
 788          * Arguments    : None
 789          * Return Value : None
 790          **********************************************************************************************************
             -*************/
 791          void fml_ctrl_deal_swing(datall* p_data)
 792          {
 793   1              switch(p_data->remote.workmode.workmode_current)
 794   1              {
 795   2                      case WORKMODULE_STANDBY:
 796   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 797   2                              p_data->remote.keyctrl.keystate_swing      = OFF;
 798   2                              break;
 799   2                      case WORKMODULE_BLOW:
 800   2                      case WORKMODULE_WARM:
 801   2                              if(p_data->remote.keyctrl.keystate_swing_pri != p_data->remote.keyctrl.keystate_swing)
 802   2                              {
 803   3                                      p_data->remote.keyctrl.keystate_swing_pri = p_data->remote.keyctrl.keystate_swing;
 804   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)                                         //?
 805   3                                      {
 806   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 807   4                                      }
 808   3                                      p_data->remote.keyctrl.keystate_enter_swing = SET;
 809   3                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;     ///< move to last step
 810   3                              }
 811   2                              else
 812   2                              {
 813   3                                      if((ON == p_data->remote.keyctrl.keystate_swing)                                ///< open swing func
 814   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))         ///< move to target step
 815   3                                      {
 816   4                                              p_data->remote.keyctrl.keystate_open_swing = ON;
 817   4                                      }
 818   3                                      else
 819   3                                      {
 820   4                                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 821   4                                      }
 822   3                              }
 823   2                              break;
 824   2                      case WORKMODULE_ABSORB:
 825   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 826   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 827   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 828   2                              {
 829   3                                      p_data->remote.keyctrl.keystate_swing      = OFF;
 830   3                              }
 831   2                              break;
 832   2                      default:
 833   2                              break;
 834   2              }
 835   1      }
 836          
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 15  

 837          /*********************************************************************************************************
             -**************
 838          * Function Name: 
 839          * Description  : 
 840          * Arguments    : None
 841          * Return Value : None
 842          **********************************************************************************************************
             -*************/
 843          void fml_ctrl_deal_timer(datall* p_data)
 844          {
 845   1              if(REMOTE != p_data->keytype)
 846   1                      return;
 847   1              
 848   1              hal_timer_mode_deal(&p_data->remote.workmode);
 849   1      }
 850          /*********************************************************************************************************
             -**************
 851          * Function Name: 
 852          * Description  : 
 853          * Arguments    : None
 854          * Return Value : None
 855          **********************************************************************************************************
             -*************/
 856          void fml_ctrl_key_logic(datall* p_data)
 857          {
 858   1              #ifdef XY_SYS_TEST_MODE
 859   1                      if(YES == p_data->testmode)
 860   1                              return;
 861   1              #endif
 862   1              
 863   1              fml_ctrl_recv_display(p_data);                                                  ///< recive remote key value
 864   1              if(REMOTE != p_data->keytype)
 865   1                      return;
 866   1      
 867   1              fml_ctrl_deal_key(p_data);                                                              ///< analysis key value 
 868   1              fml_ctrl_deal_mode(p_data);                                                             ///< control relay by diff mode
 869   1              fml_ctrl_deal_motor(p_data);                                                    ///< update motor step
 870   1              fml_ctrl_deal_swing(p_data);                                                    ///< control swing func
 871   1              fml_ctrl_deal_fan(p_data);                                                              ///< control fan machine
 872   1              fml_ctrl_chk_error(p_data);                                                             ///< check data result legal
 873   1      }
 874          
 875          /*********************************************************************************************************
             -**************
 876          * Function Name: 
 877          * Description  : 
 878          * Arguments    : None
 879          * Return Value : None
 880          **********************************************************************************************************
             -*************/
 881          void fml_ctrl_work_time(datall* p_data)
 882          {
 883   1              static workmodule  s_workmode = WORKMODULE_STANDBY;
 884   1              static unsigned int  s_work_min = 0;
 885   1      
 886   1              if(REMOTE != p_data->keytype)
 887   1                      return;
 888   1              
 889   1              if(s_workmode != p_data->remote.workmode.workmode_current)
 890   1              {
 891   2                      s_workmode = p_data->remote.workmode.workmode_current;
 892   2                      s_work_min = 0;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 10:45:04 PAGE 16  

 893   2              }       
 894   1              switch(p_data->remote.workmode.workmode_current)
 895   1              {
 896   2                      case WORKMODULE_STANDBY:
 897   2                              s_work_min = 0;
 898   2                              break;
 899   2                      case WORKMODULE_BLOW:
 900   2                      case WORKMODULE_WARM:
 901   2                      case WORKMODULE_ABSORB:
 902   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 903   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 904   2                              {
 905   3                                      s_work_min++;
 906   3                              }
 907   2                              break;
 908   2                      default:
 909   2                              break;
 910   2              }       
 911   1              if(s_work_min >= CLOCK_WORKTIME_120MIN)
 912   1              {
 913   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 914   2              }
 915   1      }
 916          
 917          /*********************************************************************************************************
             -**************
 918          * Function Name: 
 919          * Description  : 
 920          * Arguments    : None
 921          * Return Value : None
 922          **********************************************************************************************************
             -*************/
 923          void fml_ctrl_deal_alarm(datall* p_data)
 924          {
 925   1              if((p_data->temperature.value >= ALARM_HIGH_TEMP))
 926   1              {
 927   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 928   2              }
 929   1      }
 930          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4016    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =     14      36
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
