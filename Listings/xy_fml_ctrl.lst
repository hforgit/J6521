C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE XY_FML_CTRL
OBJECT MODULE PLACED IN .\Objects\xy_fml_ctrl.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE 02_FML\xy_fml_ctrl.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\01_APL;.\
                    -02_FML;.\03_HAL;.\04_SYS) DEBUG PRINT(.\Listings\xy_fml_ctrl.lst) OBJECT(.\Objects\xy_fml_ctrl.obj)

line level    source

   1          #include "xy_sys_headfile.h"
   2          
   3          /*********************************************************************************************************
             -**************
   4          * Function Name: 
   5          * Description  : 
   6          * Arguments    : None
   7          * Return Value : None
   8          **********************************************************************************************************
             -*************/
   9          void fml_ctrl_init_reg(void)
  10          {
  11   1              hal_port_init();
  12   1              hal_timer_Init();
  13   1              hal_serial_Init();
  14   1      }
  15          
  16          /*********************************************************************************************************
             -**************
  17          * Function Name: 
  18          * Description  : 
  19          * Arguments    : None
  20          * Return Value : None
  21          **********************************************************************************************************
             -*************/
  22          void fml_ctrl_init_data(datall* p_data)
  23          {
  24   1              p_data->remote.workmode.workmode_current        = WORKMODULE_DEFAULT;
  25   1              p_data->remote.keyctrl.keystate_light           = OFF;
  26   1              p_data->remote.keyctrl.keystate_swing           = OFF;
  27   1              p_data->remote.keyctrl.keystate_ptc             = OFF;
  28   1              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
  29   1              p_data->remote.keyctrl.keystate_fan_absorb      = OFF;
  30   1              p_data->remote.keyctrl.keystate_ptc_wait        = OFF;
  31   1      
  32   1              p_data->remote.keyctrl.keystate_swing_pri       = OFF;
  33   1              p_data->remote.keyctrl.keystate_enter_swing = RESET;
  34   1      
  35   1              p_data->remote.workmode.flag_workdelay_1s       = SET;
  36   1              p_data->remote.workmode.flag_workdelay_10s      = SET;
  37   1              p_data->remote.workmode.workdelay_1s            = CLOCK_DELAYTIMER_0S;
  38   1              p_data->remote.workmode.workdelay_10s           = CLOCK_DELAYTIMER_10S;
  39   1      
  40   1              p_data->remote.workmode.flag_work_colddry       = NO;
  41   1              p_data->remote.workmode.flag_work_warmdry       = NO;
  42   1      
  43   1              p_data->uart.rec_protocol                                       = RESET;
  44   1      
  45   1              p_data->uart.send_data                                          = 0;
  46   1              p_data->display.disp_icon_data                          = 0;
  47   1      }
  48          
  49          /*********************************************************************************************************
             -**************
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 2   

  50          * Function Name: 
  51          * Description  : 
  52          * Arguments    : None
  53          * Return Value : None
  54          **********************************************************************************************************
             -*************/
  55          void fml_ctrl_chk_error(datall* p_data)
  56          {
  57   1              datacommon       err;
  58   1              unsigned int motor[4] = {0};
  59   1              switchstate  state[3] = {0};
  60   1      
  61   1              motor[0] = p_data->motor.blow_target_step;
  62   1              motor[1] = p_data->motor.absorb_target_step;
  63   1              motor[2] = p_data->motor.blow_motor_step;
  64   1              motor[3] = p_data->motor.absorb_motor_step;
  65   1              state[0] = p_data->remote.keyctrl.keystate_fan_blow;
  66   1              state[1] = p_data->remote.keyctrl.keystate_fan_absorb;
  67   1              state[2] = p_data->remote.keyctrl.keystate_ptc;
  68   1              err.dat  = 0;
  69   1      
  70   1              if(YES == CTRL_CHECK_ERROR_NUMB_1(motor[0], motor[1], state[0], state[1], state[2]))
  71   1              {
  72   2                      p_data->motor.blow_target_step = RESET_STEP_ZERO;
  73   2                      err.bits.b0 = 1;
  74   2              }
  75   1      
  76   1              if(YES == CTRL_CHECK_ERROR_NUMB_2(motor[0], motor[1], state[0], state[1], state[2]))
  77   1              {
  78   2                      p_data->motor.absorb_target_step = RESET_STEP_ZERO;
  79   2                      err.bits.b1 = 1;
  80   2              }
  81   1      
  82   1              if(YES == CTRL_CHECK_ERROR_NUMB_3(motor[0], motor[1], state[0], state[1], state[2]))
  83   1              {
  84   2                      p_data->motor.absorb_target_step = RESET_STEP_ZERO;
  85   2                      err.bits.b2 = 1;
  86   2              }
  87   1      
  88   1              if(YES == CTRL_CHECK_ERROR_NUMB_4(motor[0], motor[1], state[0], state[1], state[2])) 
  89   1              {
  90   2                      p_data->remote.keyctrl.keystate_fan_blow = OFF;
  91   2                      err.bits.b3 = 1;
  92   2              }
  93   1      
  94   1              if(YES == CTRL_CHECK_ERROR_NUMB_5(motor[0], motor[2], state[0], state[1], state[2]))
  95   1              {
  96   2                      if(p_data->motor.blow_motor_step && (NO == MOTOR_CHK_STEP_IS_LEGAL(p_data->motor.blow_motor_step)))
  97   2                      {
  98   3                              p_data->remote.keyctrl.keystate_open_swing = OFF;
  99   3                      }
 100   2      
 101   2                      if(OFF == p_data->remote.keyctrl.keystate_open_swing)
 102   2                      {
 103   3                              p_data->remote.keyctrl.keystate_fan_blow = OFF;
 104   3                              err.bits.b4 = 1;
 105   3                      }
 106   2              }
 107   1      
 108   1              if(YES == CTRL_CHECK_ERROR_NUMB_6(motor[1], motor[3], state[0], state[1], state[2]))
 109   1              {
 110   2                      p_data->remote.keyctrl.keystate_fan_blow = OFF;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 3   

 111   2                      err.bits.b5 = 1;
 112   2              }
 113   1      
 114   1              if(YES == CTRL_CHECK_ERROR_NUMB_7(motor[0], motor[1], state[0], state[1], state[2]))
 115   1              {
 116   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
 117   2                      err.bits.b6 = 1;
 118   2              }
 119   1      
 120   1              p_data->error.dat = err.dat;    
 121   1      }
 122          
 123          /*********************************************************************************************************
             -**************
 124          * Function Name: 
 125          * Description  : 
 126          * Arguments    : None
 127          * Return Value : None
 128          **********************************************************************************************************
             -*************/
 129          void fml_ctrl_icon_display(datall* p_data)
 130          {       
 131   1              #ifdef XY_SYS_TEST_MODE
 132   1                      if(YES == p_data->testmode)
 133   1                              return;
 134   1              #endif
 135   1              
 136   1              if(REMOTE != p_data->keytype)
 137   1                      return;
 138   1              
 139   1              switch(p_data->remote.workmode.workmode_current)
 140   1              {
 141   2                      case WORKMODULE_STANDBY:
 142   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)                //workdelay!
 143   2                              {
 144   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_STANDBY;
 145   3                              }
 146   2                              else
 147   2                              {
 148   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 149   3                              }
 150   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 151   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 152   2                              break;
 153   2                      case WORKMODULE_BLOW:
 154   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;
 155   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 156   2                              p_data->display.disp_icon_blow      = SYM_BLOW_ON;
 157   2                              break;
 158   2                      case WORKMODULE_WARM:
 159   2                              p_data->display.disp_icon_warm      = SYM_WARM_ON;
 160   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 161   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 162   2                              break;
 163   2                      case WORKMODULE_ABSORB:
 164   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)
 165   2                              {
 166   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_ABSORB;
 167   3                              }
 168   2                              else
 169   2                              {
 170   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 4   

 171   3                              }       
 172   2                              p_data->display.disp_icon_absorb  = SYM_ABSORB_ON;
 173   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 174   2                              break;
 175   2                      default:
 176   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;                              
 177   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 178   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 179   2                              break;
 180   2              }
 181   1      }
 182          
 183          /*********************************************************************************************************
             -**************
 184          * Function Name: 
 185          * Description  : 
 186          * Arguments    : None
 187          * Return Value : None
 188          **********************************************************************************************************
             -*************/
 189          void fml_ctrl_recv_old_version(datall* p_data)
 190          {
 191   1              unsigned char i;
 192   1              unsigned char temp_sum = 0;
 193   1              unsigned char buffer[sizeof(p_data->uart.rec_uart1_dat)] = {0};
 194   1      
 195   1              memcpy(buffer, p_data->uart.rec_uart1_dat, sizeof(buffer));
 196   1              memset(p_data->uart.rec_uart1_dat, 0, sizeof(buffer));
 197   1      
 198   1              for(i=0; i<5; i++)
 199   1              {
 200   2                      temp_sum += buffer[i];
 201   2              }
 202   1      
 203   1              if(temp_sum == buffer[i])                       ///< check data 
 204   1              {
 205   2                      p_data->remote.key.keyremote.dat = buffer[2] + (buffer[3]<<8);
 206   2      
 207   2                      if(p_data->remote.key.keyremote.bits.b0)
 208   2                      {
 209   3                              p_data->remote.key.keysta = KEY_LIGHT;
 210   3                      }
 211   2                      else if(p_data->remote.key.keyremote.bits.b1)
 212   2                      {
 213   3                              p_data->remote.key.keysta = KEY_BLOW;
 214   3                      }
 215   2                      else if(p_data->remote.key.keyremote.bits.b2)
 216   2                      {
 217   3                              p_data->remote.key.keysta = KEY_ABSORB;
 218   3                      }
 219   2                      else if(p_data->remote.key.keyremote.bits.b3)
 220   2                      {
 221   3                              p_data->remote.key.keysta = KEY_WARM;
 222   3                      }
 223   2                      else if(p_data->remote.key.keyremote.bits.b4)
 224   2                      {
 225   3                              p_data->remote.key.keysta = KEY_SWING;
 226   3                      }
 227   2                      else if(p_data->remote.key.keyremote.bits.b5)
 228   2                      {
 229   3                              p_data->remote.key.keysta = KEY_RAV;
 230   3                      }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 5   

 231   2                      else if(p_data->remote.key.keyremote.bits.b6)
 232   2                      {
 233   3                              p_data->remote.key.keysta = KEY_COLD_DRY;
 234   3                      }
 235   2                      else if(p_data->remote.key.keyremote.bits.b7)
 236   2                      {
 237   3                              p_data->remote.key.keysta = KEY_STANDBY;
 238   3                      }
 239   2                      else if(p_data->remote.key.keyremote.bits.b8)
 240   2                      {
 241   3                              p_data->remote.key.keysta = KEY_WARM_DRY;
 242   3                      }
 243   2      
 244   2                      if(KEY_RELEASE != p_data->remote.key.keysta)
 245   2                      {
 246   3                              if(TOUCH == p_data->keytype)
 247   3                              {
 248   4                                      memset(&p_data->touch, 0, sizeof(p_data->touch));
 249   4                                      fml_ctrl_init_data(p_data);
 250   4                                      p_data->keytype = REMOTE;
 251   4                              }
 252   3                      }
 253   2      
 254   2                      p_data->temperature.value = buffer[4];
 255   2              }
 256   1      }
 257          
 258          /*********************************************************************************************************
             -**************
 259          * Function Name: 
 260          * Description  : 
 261          * Arguments    : None
 262          * Return Value : None
 263          **********************************************************************************************************
             -*************/
 264          void fml_ctrl_recv_new_version(datall* p_data)
 265          {
 266   1              static displaycontrol   s_dispbuffer;
 267   1              
 268   1              s_dispbuffer.length    = p_data->uart.rec_uart1_dat[2];
 269   1              s_dispbuffer.version   = p_data->uart.rec_uart1_dat[3];
 270   1              s_dispbuffer.sequence  = p_data->uart.rec_uart1_dat[4];
 271   1              s_dispbuffer.command   = (dispcommand)p_data->uart.rec_uart1_dat[5];
 272   1              s_dispbuffer.p_buffer  = &p_data->uart.rec_uart1_dat[6];
 273   1              s_dispbuffer.checkcode = p_data->uart.rec_uart1_dat[s_dispbuffer.length + 2];
 274   1      
 275   1              /* match check code about CRC-8 */
 276   1              if(hal_alg_chk_crc8(p_data->uart.rec_uart1_dat,s_dispbuffer.length + 2) == s_dispbuffer.checkcode)                      ///<
             - check data
 277   1              {
 278   2                      switch(s_dispbuffer.command)
 279   2                      {
 280   3                              case DISPLAY_CMD_REMOTE:
 281   3                                      fml_display_ack_remote(&s_dispbuffer);
 282   3                                      p_data->remote.key.keysta = fml_display_deal_remote(s_dispbuffer.p_buffer);
 283   3                                      if(KEY_RELEASE != p_data->remote.key.keysta)
 284   3                                      {
 285   4                                              if(TOUCH == p_data->keytype)
 286   4                                              {
 287   5                                                      memset(&p_data->touch, 0, sizeof(p_data->touch));
 288   5                                                      fml_ctrl_init_data(p_data);
 289   5                                                      p_data->keytype = REMOTE;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 6   

 290   5                                              }
 291   4                                      }
 292   3                                      break;
 293   3                              case DISPLAY_CMD_TEMP:
 294   3                                      p_data->temperature.value = hal_ad_cal_temperature(s_dispbuffer.p_buffer);
 295   3                                      break;
 296   3                              case DISPLAY_CMD_DIGITAL:
 297   3                                      break;
 298   3                              default:
 299   3                                      break;
 300   3                      }
 301   2              }       
 302   1              memset(p_data->uart.rec_uart1_dat, 0, s_dispbuffer.length + 3);
 303   1      }
 304          
 305          /*********************************************************************************************************
             -**************
 306          * Function Name: 
 307          * Description  : 
 308          * Arguments    : None
 309          * Return Value : None
 310          **********************************************************************************************************
             -*************/
 311          void fml_ctrl_recv_display(datall* p_data)
 312          {
 313   1              if(p_data->uart.rec_uart1_ok)
 314   1              {
 315   2                      p_data->uart.rec_uart1_ok = 0;
 316   2                      switch(p_data->uart.rec_protocol)
 317   2                      {
 318   3                              case OLD:
 319   3                                      fml_ctrl_recv_old_version(p_data);                      ///< old version(only use remote key)
 320   3                                      break;
 321   3                              case NEW:
 322   3                                      fml_ctrl_recv_new_version(p_data);                      ///< new vesion protocol
 323   3                                      break;
 324   3                              default:
 325   3                                      break;
 326   3                      }
 327   2              }
 328   1      }
 329          
 330          /*********************************************************************************************************
             -**************
 331          * Function Name: 
 332          * Description  : 
 333          * Arguments    : None
 334          * Return Value : None
 335          **********************************************************************************************************
             -*************/
 336          void fml_ctrl_deal_key(datall* p_data)
 337          {       
 338   1              switch(p_data->remote.key.keysta)
 339   1              {
 340   2                      case KEY_STANDBY:
 341   2                              if(KEY_STANDBY != p_data->remote.key.keysta_pri)
 342   2                              {
 343   3                                      p_data->remote.key.keysta_pri = KEY_STANDBY;
 344   3      
 345   3                                      p_data->buzzer.normal_bee_on = ON;
 346   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 347   3      
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 7   

 348   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 349   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 350   3                              }
 351   2                              else
 352   2                              {
 353   3                                      p_data->buzzer.burn_bee_on = ON;
 354   3                              }
 355   2                              break;
 356   2                      case KEY_BLOW:
 357   2                              if(KEY_BLOW != p_data->remote.key.keysta_pri)
 358   2                              {
 359   3                                      p_data->remote.key.keysta_pri = KEY_BLOW;
 360   3      
 361   3                                      p_data->buzzer.normal_bee_on = ON;
 362   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_BLOW;
 363   3      
 364   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 365   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 366   3                              }
 367   2                              else
 368   2                              {
 369   3                                      p_data->buzzer.burn_bee_on = ON;
 370   3                              }
 371   2                              break;
 372   2                      case KEY_ABSORB:
 373   2                              if(KEY_ABSORB != p_data->remote.key.keysta_pri)
 374   2                              {
 375   3                                      p_data->remote.key.keysta_pri = KEY_ABSORB;
 376   3                                      
 377   3                                      p_data->buzzer.normal_bee_on = ON;
 378   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_ABSORB;
 379   3      
 380   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 381   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 382   3                              }
 383   2                              else
 384   2                              {
 385   3                                      p_data->buzzer.burn_bee_on = ON;
 386   3                              }
 387   2                              break;
 388   2                      case KEY_WARM:
 389   2                              if(KEY_WARM != p_data->remote.key.keysta_pri)                                   
 390   2                              {
 391   3                                      p_data->remote.key.keysta_pri = KEY_WARM;
 392   3      
 393   3                                      p_data->buzzer.normal_bee_on = ON;
 394   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_WARM;
 395   3      
 396   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 397   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 398   3                              }
 399   2                              else
 400   2                              {
 401   3                                      p_data->buzzer.burn_bee_on = ON;
 402   3                              }
 403   2                              break;
 404   2                      case KEY_COLD_DRY:
 405   2                              if(KEY_COLD_DRY != p_data->remote.key.keysta_pri)
 406   2                              {
 407   3                                      p_data->remote.key.keysta_pri = KEY_COLD_DRY;
 408   3                                      
 409   3                                      p_data->buzzer.normal_bee_on = ON;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 8   

 410   3                                      //p_data->remote.workmode.workmode_cur = WORKMODULE_BLOW;
 411   3      
 412   3                                      p_data->remote.workmode.flag_work_colddry = YES;
 413   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 414   3                              }
 415   2                              else
 416   2                              {
 417   3                                      p_data->buzzer.burn_bee_on = ON;
 418   3                              }
 419   2                              break;
 420   2                      case KEY_WARM_DRY:
 421   2                              if(KEY_WARM_DRY != p_data->remote.key.keysta_pri)
 422   2                              {
 423   3                                      p_data->remote.key.keysta_pri = KEY_WARM_DRY;
 424   3                                      
 425   3                                      p_data->buzzer.normal_bee_on = ON;
 426   3                                      //p_data->remote.workmode.workmode_cur = WORKMODULE_WARM;
 427   3                                      
 428   3                                      p_data->remote.workmode.flag_work_warmdry = YES;
 429   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 430   3                              }
 431   2                              else
 432   2                              {
 433   3                                      p_data->buzzer.burn_bee_on = ON;
 434   3                              }
 435   2                              break;
 436   2                      case KEY_SWING:
 437   2                              /* only blow mode or warm mode and dry can enter this condition */
 438   2                              if(((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 439   2                                      || (WORKMODULE_WARM == p_data->remote.workmode.workmode_current)))
 440   2                              {
 441   3                                      p_data->buzzer.normal_bee_on = ON;
 442   3                                      if(OFF == p_data->remote.keyctrl.keystate_swing)
 443   3                                      {
 444   4                                              /* open swing page */
 445   4                                              p_data->remote.keyctrl.keystate_swing = ON;
 446   4                                      }
 447   3                                      else
 448   3                                      {
 449   4                                              /* close swing page */
 450   4                                              p_data->remote.keyctrl.keystate_swing = OFF;
 451   4                                      }
 452   3                              }
 453   2                              else
 454   2                              {
 455   3                                      p_data->buzzer.burn_bee_on = ON;
 456   3                              }
 457   2                              break;
 458   2                      case KEY_LIGHT:
 459   2                              p_data->buzzer.normal_bee_on = ON;
 460   2                              if(OFF == p_data->remote.keyctrl.keystate_light)
 461   2                              {
 462   3                                      p_data->remote.keyctrl.keystate_light = ON;
 463   3                              }
 464   2                              else
 465   2                              {
 466   3                                      p_data->remote.keyctrl.keystate_light = OFF;
 467   3                              }
 468   2                              break;
 469   2                      default:
 470   2                              break;
 471   2              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 9   

 472   1              p_data->remote.key.keysta = KEY_RELEASE;
 473   1      }
 474          
 475          /*********************************************************************************************************
             -**************
 476          * Function Name: 
 477          * Description  : 
 478          * Arguments    : None
 479          * Return Value : None
 480          **********************************************************************************************************
             -*************/
 481          void fml_ctrl_deal_automode(workmoduleflag* p_mode)                                                     //check
 482          {
 483   1              static switchstate       s_onetime  = RESET;
 484   1              static unsigned char s_time_dry_tmp = 0;
 485   1              static unsigned int  s_time_dry_min = 0;
 486   1              static switchstate       s_state    = RESET;
 487   1      
 488   1              if((YES == p_mode->flag_work_warmdry) || (YES == p_mode->flag_work_colddry))
 489   1              {
 490   2                      if(YES == p_mode->flag_work_warmdry)
 491   2                      {
 492   3                              if(WARM != s_state)
 493   3                              {
 494   4                                      s_onetime = RESET;
 495   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 496   4                              }
 497   3                              s_state = WARM;
 498   3                      }
 499   2                      else
 500   2                      {
 501   3                              if(COLD != s_state)
 502   3                              {
 503   4                                      s_onetime = RESET;
 504   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 505   4                              }
 506   3                              s_state = COLD;
 507   3                      }
 508   2                      if(YES == p_mode->flag_work_warmdry)
 509   2                      {
 510   3                              if((s_time_dry_min % (CLOCK_WARMDRY_WARM_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 511   3                                      < (CLOCK_WARMDRY_WARM_10MIN - CLOCK_DELAYTIMER_10S))
 512   3                              {
 513   4                                      p_mode->workmode_current = WORKMODULE_WARM;
 514   4                              }
 515   3                              else
 516   3                              {
 517   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 518   4                              }
 519   3                      }
 520   2                      else
 521   2                      {
 522   3                              if((s_time_dry_min % (CLOCK_COLDDRY_COLD_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 523   3                                      < CLOCK_COLDDRY_COLD_10MIN)
 524   3                              {
 525   4                                      p_mode->workmode_current = WORKMODULE_BLOW;
 526   4                              }
 527   3                              else
 528   3                              {
 529   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 530   4                              }
 531   3                      }               
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 10  

 532   2                      if(RESET == s_onetime)
 533   2                      {
 534   3                              s_onetime = SET;
 535   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 536   3                      }
 537   2                      if(YES == CTRL_EXCEED_DELAY_TIMER(1, p_mode->workdelay_cyc, s_time_dry_tmp))
 538   2                      {
 539   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 540   3                              s_time_dry_min++;
 541   3                              if(s_time_dry_min >= CLOCK_WORKDRY_ALL_60MIN)
 542   3                              {
 543   4                                      p_mode->workmode_current = WORKMODULE_STANDBY;
 544   4                                      if(YES == p_mode->flag_work_warmdry)
 545   4                                      {       
 546   5                                              p_mode->flag_work_warmdry = NO;
 547   5                                      }
 548   4                                      else
 549   4                                      {
 550   5                                              p_mode->flag_work_colddry = NO;
 551   5                                      }
 552   4                              }
 553   3                      }
 554   2              }
 555   1              else
 556   1              {
 557   2                      s_state = RESET;
 558   2              }
 559   1      }
 560          
 561          /*********************************************************************************************************
             -**************
 562          * Function Name: 
 563          * Description  : 
 564          * Arguments    : None
 565          * Return Value : None
 566          **********************************************************************************************************
             -*************/
 567          void fml_ctrl_deal_mode(datall* p_data)
 568          {       
 569   1              static switchstate   s_onetime[2] = {STEP1, RESET};
 570   1              static unsigned char s_time_ptc_worktime = 0;
 571   1      
 572   1              fml_ctrl_deal_automode(&p_data->remote.workmode);
 573   1              switch(p_data->remote.workmode.workmode_current)
 574   1              {
 575   2                      case WORKMODULE_STANDBY:
 576   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 577   2                              {
 578   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 579   3                              }
 580   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 581   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 582   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 583   2                              p_data->remote.key.keysta_pri = KEY_STANDBY;
 584   2                              break;
 585   2                      case WORKMODULE_BLOW:
 586   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 587   2                              {
 588   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 589   3                              }
 590   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 591   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 11  

 592   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 593   2                              break;
 594   2                      case WORKMODULE_WARM:
 595   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)       ///< delay 10s
 596   2                              {
 597   3                                      if(ON == p_data->remote.keyctrl.keystate_move_target)                   ///< move target step
 598   3                                      {
 599   4                                              if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
 600   4                                              {
 601   5                                                      p_data->remote.workmode.flag_workdelay_1s = RESET;
 602   5                                                      p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 603   5                                              }                                       
 604   4                                              p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 605   4                                      }
 606   3                                      else
 607   3                                      {
 608   4                                              p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;             ///< start from last step
 609   4                                      }
 610   3                              }
 611   2                      
 612   2                              if(p_data->remote.workmode.workdelay_1s >= CLOCK_DELAYTIMER_1S)
 613   2                              {
 614   3                                      if((OFF == p_data->remote.keyctrl.keystate_ptc_wait) 
 615   3                              //              && (YES == MOTOR_CHK_MOVE_TO_TARGET))
 616   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))
 617   3                                      {
 618   4                                              p_data->remote.keyctrl.keystate_ptc   = ON;                     ///< restart ptc
 619   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 620   4                                      }
 621   3                              }
 622   2                              break;
 623   2                      case WORKMODULE_ABSORB:
 624   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 625   2                              {
 626   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 627   3                              }
 628   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 629   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 630   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 631   2                              break;
 632   2                      default:
 633   2                              break;
 634   2              }
 635   1              if(p_data->remote.keyctrl.keystate_ptc_pri != p_data->remote.keyctrl.keystate_ptc)
 636   1              {
 637   2                      if(ON == p_data->remote.keyctrl.keystate_ptc)
 638   2                      {
 639   3                              if(RESET == s_onetime[1])
 640   3                              {
 641   4                                      s_time_ptc_worktime = p_data->remote.workmode.workdelay_cyc;
 642   4                              }
 643   3                              s_onetime[1] = SET;
 644   3                      }
 645   2                      else
 646   2                      {
 647   3                              s_onetime[1] = RESET;
 648   3                      }
 649   2                      p_data->remote.keyctrl.keystate_ptc_pri = p_data->remote.keyctrl.keystate_ptc;  
 650   2              }
 651   1              else
 652   1              {
 653   2                      if(ON == p_data->remote.keyctrl.keystate_ptc_pri)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 12  

 654   2                      {
 655   3                              if(YES == CTRL_EXCEED_DELAY_TIMER(0, p_data->remote.workmode.workdelay_cyc, s_time_ptc_worktime))
 656   3                              {
 657   4                                      p_data->remote.keyctrl.keystate_ptc_delay = YES;
 658   4                              }
 659   3                      }
 660   2                      else
 661   2                      {
 662   3                              p_data->remote.keyctrl.keystate_ptc_delay = NO;
 663   3                      }
 664   2              }
 665   1      }
 666          
 667          /*********************************************************************************************************
             -**************
 668          * Function Name: 
 669          * Description  : 
 670          * Arguments    : None
 671          * Return Value : None
 672          **********************************************************************************************************
             -*************/
 673          void fml_ctrl_deal_motor(datall* p_data)
 674          {
 675   1              static switchstate s_step = STEP1;
 676   1      
 677   1              switch(p_data->remote.workmode.workmode_current)
 678   1              {
 679   2                      case WORKMODULE_STANDBY:
 680   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 681   2                              {
 682   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 683   3                                      p_data->motor.absorb_target_step = RESET_STEP_ZERO;
 684   3      
 685   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 686   3                              }
 687   2                              else
 688   2                              {
 689   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 690   3                                      {
 691   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;
 692   4                                      }
 693   3                              }
 694   2                              break;  
 695   2                      case WORKMODULE_BLOW:
 696   2                      case WORKMODULE_WARM:
 697   2                              if((p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 698   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))
 699   2                              {
 700   3                                      
 701   3                                      p_data->motor.absorb_target_step = RESET_STEP_ZERO;
 702   3                                      
 703   3                                      if(RESET == p_data->remote.keyctrl.keystate_enter_swing)
 704   3                                      {
 705   4                                              s_step = STEP1;
 706   4                                              p_data->remote.keyctrl.keystate_enter_swing = SET;
 707   4                                              p_data->motor.blow_target_step     = TARGET_STEP_BLOW;
 708   4                                              p_data->motor.blow_motor_step_pri  = TARGET_STEP_BLOW;
 709   4                                              p_data->motor.blow_target_step_pri = TARGET_LOW_SWING;
 710   4                                      }
 711   3                                      else
 712   3                                      {
 713   4                                              if(ON == p_data->remote.keyctrl.keystate_swing)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 13  

 714   4                                              {
 715   5                                                      switch(s_step)
 716   5                                                      {
 717   6                                                              case STEP1:
 718   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 719   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 720   6                                                                      {
 721   7                                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 722   7                                                                              s_step = STEP2;
 723   7                                                                      }
 724   6                                                                      break;
 725   6                                                              case STEP2:
 726   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 727   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 728   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 729   6                                                                      {
 730   7                                                                              s_step = STEP3;
 731   7                                                                      }
 732   6                                                                      break;
 733   6                                                              case STEP3:
 734   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 735   6                                                                      if(p_data->motor.blow_motor_step == TARGET_HIGH_SWING)
 736   6                                                                      {
 737   7                                                                              p_data->motor.blow_target_step          = TARGET_LOW_SWING;
 738   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;             ///< save target step
 739   7                                                                      }
 740   6                                                                      else if(p_data->motor.blow_motor_step == TARGET_LOW_SWING)
 741   6                                                                      {
 742   7                                                                              p_data->motor.blow_target_step          = TARGET_HIGH_SWING;
 743   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_HIGH_SWING;    ///< save target step
 744   7                                                                      }
 745   6                                                                      else
 746   6                                                                      {
 747   7                                                                              if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 748   7                                                                              {
 749   8                                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 750   8                                                                              }
 751   7                                                                      }
 752   6                                                                      break;
 753   6                                                              default:
 754   6                                                                      break;
 755   6                                                      }
 756   5                                              }
 757   4                                              else
 758   4                                              {
 759   5                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 760   5                                              }
 761   4                                              
 762   4                                              
 763   4                                              if(YES == MOTOR_CHK_MOVE_TO_TARGET)
 764   4                                              {
 765   5                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 766   5                                              }
 767   4                                      }
 768   3                              }
 769   2                              break;
 770   2                      case WORKMODULE_ABSORB:
 771   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 772   2                              {
 773   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 774   3                                      p_data->motor.absorb_target_step = TARGET_STEP_ABSORB;
 775   3      
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 14  

 776   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 777   3                              }
 778   2                              else
 779   2                              {
 780   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 781   3                                      {
 782   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;    
 783   4                                      }
 784   3                              }
 785   2                              break;
 786   2                      default:
 787   2                              break;
 788   2              }
 789   1      }
 790          
 791          /*********************************************************************************************************
             -**************
 792          * Function Name: 
 793          * Description  : 
 794          * Arguments    : None
 795          * Return Value : None
 796          **********************************************************************************************************
             -*************/
 797          void fml_ctrl_deal_fan(datall* p_data)
 798          {
 799   1              switch(p_data->remote.workmode.workmode_current)
 800   1              {
 801   2                      case WORKMODULE_STANDBY:
 802   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 803   2                              {
 804   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 805   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 806   3                              }
 807   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 808   2                              break;
 809   2                      case WORKMODULE_BLOW:
 810   2                      case WORKMODULE_WARM:
 811   2                              if((ON == p_data->remote.keyctrl.keystate_move_target) ///< move to target step.
 812   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))  ///< need open blow fan when work swing func.
 813   2                              {
 814   3                                      p_data->remote.workmode.flag_workdelay_1s = SET;
 815   3                                      p_data->remote.keyctrl.keystate_fan_blow  = ON;
 816   3                              }
 817   2                              else
 818   2                              {
 819   3                                      if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 820   3                                      {
 821   4                                              p_data->remote.workmode.flag_workdelay_1s       = RESET;
 822   4                                              p_data->remote.keyctrl.keystate_move_target = OFF;
 823   4                                              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 824   4                                      }                                                               
 825   3                              }
 826   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 827   2                              break;
 828   2                      case WORKMODULE_ABSORB:
 829   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 830   2                              {
 831   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 832   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 833   3                                              if(YES == MOTOR_CHK_MOVE_TO_TARGET)
 834   3                                              {
 835   4                                                      p_data->remote.keyctrl.keystate_fan_absorb      = ON;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 15  

 836   4                                              }
 837   3                              }
 838   2                              break;
 839   2                      default:
 840   2                              break;
 841   2              }
 842   1      }
 843          
 844          /*********************************************************************************************************
             -**************
 845          * Function Name: 
 846          * Description  : 
 847          * Arguments    : None
 848          * Return Value : None
 849          **********************************************************************************************************
             -*************/
 850          void fml_ctrl_deal_swing(datall* p_data)
 851          {
 852   1              switch(p_data->remote.workmode.workmode_current)
 853   1              {
 854   2                      case WORKMODULE_STANDBY:
 855   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 856   2                              p_data->remote.keyctrl.keystate_swing      = OFF;
 857   2                              break;
 858   2                      case WORKMODULE_BLOW:
 859   2                      case WORKMODULE_WARM:
 860   2                              if(p_data->remote.keyctrl.keystate_swing_pri != p_data->remote.keyctrl.keystate_swing)
 861   2                              {
 862   3                                      p_data->remote.keyctrl.keystate_swing_pri = p_data->remote.keyctrl.keystate_swing;
 863   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)                                         //?
 864   3                                      {
 865   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 866   4                                      }
 867   3                                      p_data->remote.keyctrl.keystate_enter_swing = SET;
 868   3                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;     ///< move to last step
 869   3                              }
 870   2                              else
 871   2                              {
 872   3                                      if((ON == p_data->remote.keyctrl.keystate_swing)                                ///< open swing func
 873   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))         ///< move to target step
 874   3                                      {
 875   4                                              p_data->remote.keyctrl.keystate_open_swing = ON;
 876   4                                      }
 877   3                                      else
 878   3                                      {
 879   4                                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 880   4                                      }
 881   3                              }
 882   2                              break;
 883   2                      case WORKMODULE_ABSORB:
 884   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 885   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 886   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 887   2                              {
 888   3                                      p_data->remote.keyctrl.keystate_swing      = OFF;
 889   3                              }
 890   2                              break;
 891   2                      default:
 892   2                              break;
 893   2              }
 894   1      }
 895          
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 16  

 896          /*********************************************************************************************************
             -**************
 897          * Function Name: 
 898          * Description  : 
 899          * Arguments    : None
 900          * Return Value : None
 901          **********************************************************************************************************
             -*************/
 902          void fml_ctrl_deal_timer(datall* p_data)
 903          {
 904   1              if(REMOTE != p_data->keytype)
 905   1                      return;
 906   1              
 907   1              hal_timer_mode_deal(&p_data->remote.workmode);
 908   1      }
 909          /*********************************************************************************************************
             -**************
 910          * Function Name: 
 911          * Description  : 
 912          * Arguments    : None
 913          * Return Value : None
 914          **********************************************************************************************************
             -*************/
 915          void fml_ctrl_key_logic(datall* p_data)
 916          {
 917   1              #ifdef XY_SYS_TEST_MODE
 918   1                      if(YES == p_data->testmode)
 919   1                              return;
 920   1              #endif
 921   1              
 922   1              fml_ctrl_recv_display(p_data);                                                  ///< recive remote key value
 923   1              if(REMOTE != p_data->keytype)
 924   1                      return;
 925   1      
 926   1              fml_ctrl_deal_key(p_data);                                                              ///< analysis key value 
 927   1              fml_ctrl_deal_mode(p_data);                                                             ///< control relay by diff mode
 928   1              fml_ctrl_deal_motor(p_data);                                                    ///< update motor step
 929   1              fml_ctrl_deal_swing(p_data);                                                    ///< control swing func
 930   1              fml_ctrl_deal_fan(p_data);                                                              ///< control fan machine
 931   1              fml_ctrl_chk_error(p_data);                                                             ///< check data result legal
 932   1      }
 933          
 934          /*********************************************************************************************************
             -**************
 935          * Function Name: 
 936          * Description  : 
 937          * Arguments    : None
 938          * Return Value : None
 939          **********************************************************************************************************
             -*************/
 940          void fml_ctrl_work_time(datall* p_data)
 941          {
 942   1              static workmodule  s_workmode = WORKMODULE_STANDBY;
 943   1              static unsigned int  s_work_min = 0;
 944   1      
 945   1              if(REMOTE != p_data->keytype)
 946   1                      return;
 947   1              
 948   1              if(s_workmode != p_data->remote.workmode.workmode_current)
 949   1              {
 950   2                      s_workmode = p_data->remote.workmode.workmode_current;
 951   2                      s_work_min = 0;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:55:06 PAGE 17  

 952   2              }       
 953   1              switch(p_data->remote.workmode.workmode_current)
 954   1              {
 955   2                      case WORKMODULE_STANDBY:
 956   2                              s_work_min = 0;
 957   2                              break;
 958   2                      case WORKMODULE_BLOW:
 959   2                      case WORKMODULE_WARM:
 960   2                      case WORKMODULE_ABSORB:
 961   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 962   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 963   2                              {
 964   3                                      s_work_min++;
 965   3                              }
 966   2                              break;
 967   2                      default:
 968   2                              break;
 969   2              }       
 970   1              if(s_work_min >= CLOCK_WORKTIME_120MIN)
 971   1              {
 972   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 973   2              }
 974   1      }
 975          
 976          /*********************************************************************************************************
             -**************
 977          * Function Name: 
 978          * Description  : 
 979          * Arguments    : None
 980          * Return Value : None
 981          **********************************************************************************************************
             -*************/
 982          void fml_ctrl_deal_alarm(datall* p_data)
 983          {
 984   1              if((p_data->temperature.value >= ALARM_HIGH_TEMP))
 985   1              {
 986   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 987   2              }
 988   1      }
 989          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4591    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =     20      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
