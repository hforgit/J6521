C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE XY_FML_CTRL
OBJECT MODULE PLACED IN .\Objects\xy_fml_ctrl.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE 02_FML\xy_fml_ctrl.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\01_APL;.\
                    -02_FML;.\03_HAL;.\04_SYS) DEBUG PRINT(.\Listings\xy_fml_ctrl.lst) OBJECT(.\Objects\xy_fml_ctrl.obj)

line level    source

   1          #include "xy_sys_headfile.h"
   2          
   3          /*********************************************************************************************************
             -**************
   4          * Function Name: 
   5          * Description  : 
   6          * Arguments    : None
   7          * Return Value : None
   8          **********************************************************************************************************
             -*************/
   9          void fml_ctrl_init_reg(void)
  10          {
  11   1              hal_port_init();
  12   1              hal_timer_Init();
  13   1              hal_serial_Init();
  14   1      }
  15          
  16          /*********************************************************************************************************
             -**************
  17          * Function Name: 
  18          * Description  : 
  19          * Arguments    : None
  20          * Return Value : None
  21          **********************************************************************************************************
             -*************/
  22          void fml_ctrl_init_data(datall* p_data)
  23          {
  24   1              p_data->remote.workmode.workmode_current        = WORKMODULE_DEFAULT;
  25   1              p_data->remote.keyctrl.keystate_light           = OFF;
  26   1              p_data->remote.keyctrl.keystate_swing           = OFF;
  27   1              p_data->remote.keyctrl.keystate_ptc             = OFF;
  28   1              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
  29   1              p_data->remote.keyctrl.keystate_fan_absorb      = OFF;
  30   1              p_data->remote.keyctrl.keystate_ptc_wait        = OFF;
  31   1      
  32   1              p_data->remote.keyctrl.keystate_swing_pri       = OFF;
  33   1              p_data->remote.keyctrl.keystate_enter_swing = RESET;
  34   1      
  35   1              p_data->remote.workmode.flag_workdelay_1s       = SET;
  36   1              p_data->remote.workmode.flag_workdelay_10s      = SET;
  37   1              p_data->remote.workmode.workdelay_1s            = CLOCK_DELAYTIMER_0S;
  38   1              p_data->remote.workmode.workdelay_10s           = CLOCK_DELAYTIMER_10S;
  39   1      
  40   1              p_data->remote.workmode.flag_work_colddry       = NO;
  41   1              p_data->remote.workmode.flag_work_warmdry       = NO;
  42   1      
  43   1              p_data->uart.send_data                                          = 0;
  44   1              p_data->display.disp_icon_data                          = 0;
  45   1      }
  46          
  47          /*********************************************************************************************************
             -**************
  48          * Function Name: 
  49          * Description  : 
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 2   

  50          * Arguments    : None
  51          * Return Value : None
  52          **********************************************************************************************************
             -*************/
  53          void fml_ctrl_chk_error(datall* p_data)
  54          {
  55   1              datacommon       err;
  56   1              unsigned int motor[2] = {0};
  57   1              switchstate  state[3] = {0};
  58   1      
  59   1              motor[0] = p_data->motor.blow_target_step;
  60   1              motor[1] = p_data->motor.blow_motor_step;
  61   1              state[0] = p_data->remote.keyctrl.keystate_fan_blow;
  62   1              state[1] = p_data->remote.keyctrl.keystate_fan_absorb;
  63   1              state[2] = p_data->remote.keyctrl.keystate_ptc;
  64   1              err.dat  = 0;
  65   1      
  66   1              if(YES == CTRL_CHECK_ERROR_NUMB_1(motor[0], motor[1], state[0], state[1], state[2]))
  67   1              {
  68   2                      p_data->motor.blow_target_step = RESET_STEP_ZERO;
  69   2                      err.bits.b0 = 1;
  70   2              }
  71   1      
  72   1              if(YES == CTRL_CHECK_ERROR_NUMB_2(motor[0], motor[1], state[0], state[1], state[2]))
  73   1              {
  74   2                      p_data->remote.keyctrl.keystate_fan_blow = OFF;
  75   2                      err.bits.b1 = 1;
  76   2              }
  77   1      
  78   1              if(YES == CTRL_CHECK_ERROR_NUMB_3(motor[0], motor[1], state[0], state[1], state[2]))
  79   1              {
  80   2                      if(p_data->motor.blow_motor_step && (NO == MOTOR_CHK_STEP_IS_LEGAL(p_data->motor.blow_motor_step)))
  81   2                      {
  82   3                              p_data->remote.keyctrl.keystate_open_swing = OFF;
  83   3                      }
  84   2       
  85   2                      if(OFF == p_data->remote.keyctrl.keystate_open_swing)
  86   2                      {
  87   3                              p_data->remote.keyctrl.keystate_fan_blow = OFF;
  88   3                              err.bits.b2 = 1;        
  89   3                      }
  90   2              }
  91   1              
  92   1              if(YES == CTRL_CHECK_ERROR_NUMB_4(motor[0], motor[1], state[0], state[1], state[2]))
  93   1              {
  94   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
  95   2                      err.bits.b3 = 1;
  96   2              }
  97   1              
  98   1              if(YES == CTRL_CHECK_ERROR_NUMB_5(motor[0], motor[1], state[0], state[1], state[2]))
  99   1              {
 100   2                      p_data->remote.keyctrl.keystate_fan_absorb = OFF;
 101   2                      err.bits.b4 = 1;
 102   2              }
 103   1      
 104   1              if(YES == CTRL_CHECK_ERROR_NUMB_6(motor[0], motor[1], state[0], state[1], state[2]))
 105   1              {
 106   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
 107   2                      err.bits.b5 = 1;
 108   2              }
 109   1              
 110   1              p_data->error.dat = err.dat;    
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 3   

 111   1      }
 112          
 113          /*********************************************************************************************************
             -**************
 114          * Function Name: 
 115          * Description  : 
 116          * Arguments    : None
 117          * Return Value : None
 118          **********************************************************************************************************
             -*************/
 119          void fml_ctrl_icon_display(datall* p_data)
 120          {       
 121   1              #ifdef XY_SYS_TEST_MODE
 122   1                      if(YES == p_data->testmode)
 123   1                              return;
 124   1              #endif
 125   1              
 126   1              if(REMOTE != p_data->keytype)
 127   1                      return;
 128   1              
 129   1              switch(p_data->remote.workmode.workmode_current)
 130   1              {
 131   2                      case WORKMODULE_STANDBY:
 132   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)                //workdelay!
 133   2                              {
 134   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_STANDBY;
 135   3                              }
 136   2                              else
 137   2                              {
 138   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 139   3                              }
 140   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 141   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 142   2                              break;
 143   2                      case WORKMODULE_BLOW:
 144   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;
 145   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 146   2                              p_data->display.disp_icon_blow      = SYM_BLOW_ON;
 147   2                              break;
 148   2                      case WORKMODULE_WARM:
 149   2                              p_data->display.disp_icon_warm      = SYM_WARM_ON;
 150   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 151   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 152   2                              break;
 153   2                      case WORKMODULE_ABSORB:
 154   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)
 155   2                              {
 156   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_ABSORB;
 157   3                              }
 158   2                              else
 159   2                              {
 160   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 161   3                              }       
 162   2                              p_data->display.disp_icon_absorb  = SYM_ABSORB_ON;
 163   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 164   2                              break;
 165   2                      default:
 166   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;                              
 167   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 168   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 169   2                              break;
 170   2              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 4   

 171   1      }
 172          
 173          /*********************************************************************************************************
             -**************
 174          * Function Name: 
 175          * Description  : 
 176          * Arguments    : None
 177          * Return Value : None
 178          **********************************************************************************************************
             -*************/
 179          void fml_ctrl_recv_old_version(datall* p_data)
 180          {
 181   1              unsigned char i;
 182   1              unsigned char temp_sum = 0;
 183   1              unsigned char buffer[sizeof(p_data->uart.rec_uart1_dat)] = {0};
 184   1      
 185   1              memcpy(buffer, p_data->uart.rec_uart1_dat, sizeof(buffer));
 186   1              memset(p_data->uart.rec_uart1_dat, 0, sizeof(buffer));
 187   1      
 188   1              for(i=0; i<5; i++)
 189   1              {
 190   2                      temp_sum += buffer[i];
 191   2              }
 192   1      
 193   1              if(temp_sum == buffer[i])                       ///< check data 
 194   1              {
 195   2                      p_data->remote.key.keyremote.dat = buffer[2] + (buffer[3]<<8);
 196   2      
 197   2                      if(p_data->remote.key.keyremote.bits.b0)
 198   2                      {
 199   3                              p_data->remote.key.keysta = KEY_LIGHT;
 200   3                      }
 201   2                      else if(p_data->remote.key.keyremote.bits.b1)
 202   2                      {
 203   3                              p_data->remote.key.keysta = KEY_BLOW;
 204   3                      }
 205   2                      else if(p_data->remote.key.keyremote.bits.b2)
 206   2                      {
 207   3                              p_data->remote.key.keysta = KEY_ABSORB;
 208   3                      }
 209   2                      else if(p_data->remote.key.keyremote.bits.b3)
 210   2                      {
 211   3                              p_data->remote.key.keysta = KEY_WARM;
 212   3                      }
 213   2                      else if(p_data->remote.key.keyremote.bits.b4)
 214   2                      {
 215   3                              p_data->remote.key.keysta = KEY_SWING;
 216   3                      }
 217   2                      else if(p_data->remote.key.keyremote.bits.b5)
 218   2                      {
 219   3                              p_data->remote.key.keysta = KEY_RAV;
 220   3                      }
 221   2                      else if(p_data->remote.key.keyremote.bits.b6)
 222   2                      {
 223   3                              p_data->remote.key.keysta = KEY_COLD_DRY;
 224   3                      }
 225   2                      else if(p_data->remote.key.keyremote.bits.b7)
 226   2                      {
 227   3                              p_data->remote.key.keysta = KEY_STANDBY;
 228   3                      }
 229   2                      else if(p_data->remote.key.keyremote.bits.b8)
 230   2                      {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 5   

 231   3                              p_data->remote.key.keysta = KEY_WARM_DRY;
 232   3                      }
 233   2      
 234   2                      if(KEY_RELEASE != p_data->remote.key.keysta)
 235   2                      {
 236   3                              if(TOUCH == p_data->keytype)
 237   3                              {
 238   4                                      memset(&p_data->touch, 0, sizeof(p_data->touch));
 239   4                                      fml_ctrl_init_data(p_data);
 240   4                                      p_data->keytype = REMOTE;
 241   4                              }
 242   3                      }
 243   2      
 244   2                      p_data->temperature.value = buffer[4];
 245   2              }
 246   1      }
 247          
 248          /*********************************************************************************************************
             -**************
 249          * Function Name: 
 250          * Description  : 
 251          * Arguments    : None
 252          * Return Value : None
 253          **********************************************************************************************************
             -*************/
 254          void fml_ctrl_recv_display(datall* p_data)
 255          {
 256   1              if(p_data->uart.rec_uart1_ok)
 257   1              {
 258   2                      p_data->uart.rec_uart1_ok = 0;
 259   2                      fml_ctrl_recv_old_version(p_data);                      ///< old version(only use remote key)
 260   2              }
 261   1      }
 262          
 263          /*********************************************************************************************************
             -**************
 264          * Function Name: 
 265          * Description  : 
 266          * Arguments    : None
 267          * Return Value : None
 268          **********************************************************************************************************
             -*************/
 269          void fml_ctrl_deal_key(datall* p_data)
 270          {       
 271   1              switch(p_data->remote.key.keysta)
 272   1              {
 273   2                      case KEY_STANDBY:
 274   2                              if(KEY_STANDBY != p_data->remote.key.keysta_pri)
 275   2                              {
 276   3                                      p_data->remote.key.keysta_pri = KEY_STANDBY;
 277   3      
 278   3                                      p_data->buzzer.normal_bee_on = ON;
 279   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 280   3      
 281   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 282   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 283   3                              }
 284   2                              else
 285   2                              {
 286   3                                      p_data->buzzer.burn_bee_on = ON;
 287   3                              }
 288   2                              break;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 6   

 289   2                      case KEY_BLOW:
 290   2                              if(KEY_BLOW != p_data->remote.key.keysta_pri)
 291   2                              {
 292   3                                      p_data->remote.key.keysta_pri = KEY_BLOW;
 293   3      
 294   3                                      p_data->buzzer.normal_bee_on = ON;
 295   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_BLOW;
 296   3      
 297   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 298   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 299   3                              }
 300   2                              else
 301   2                              {
 302   3                                      p_data->buzzer.burn_bee_on = ON;
 303   3                              }
 304   2                              break;
 305   2                      case KEY_ABSORB:
 306   2                              if(KEY_ABSORB != p_data->remote.key.keysta_pri)
 307   2                              {
 308   3                                      p_data->remote.key.keysta_pri = KEY_ABSORB;
 309   3                                      
 310   3                                      p_data->buzzer.normal_bee_on = ON;
 311   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_ABSORB;
 312   3      
 313   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 314   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 315   3                              }
 316   2                              else
 317   2                              {
 318   3                                      p_data->buzzer.burn_bee_on = ON;
 319   3                              }
 320   2                              break;
 321   2                      case KEY_WARM:
 322   2                              if(KEY_WARM != p_data->remote.key.keysta_pri)                                   
 323   2                              {
 324   3                                      p_data->remote.key.keysta_pri = KEY_WARM;
 325   3      
 326   3                                      p_data->buzzer.normal_bee_on = ON;
 327   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_WARM;
 328   3      
 329   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 330   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 331   3                              }
 332   2                              else
 333   2                              {
 334   3                                      p_data->buzzer.burn_bee_on = ON;
 335   3                              }
 336   2                              break;
 337   2                      case KEY_COLD_DRY:
 338   2                              if(KEY_COLD_DRY != p_data->remote.key.keysta_pri)
 339   2                              {
 340   3                                      p_data->remote.key.keysta_pri = KEY_COLD_DRY;
 341   3                                      
 342   3                                      p_data->buzzer.normal_bee_on = ON;
 343   3                                      
 344   3      
 345   3                                      p_data->remote.workmode.flag_work_colddry = YES;
 346   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 347   3                              }
 348   2                              else
 349   2                              {
 350   3                                      p_data->buzzer.burn_bee_on = ON;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 7   

 351   3                              }
 352   2                              break;
 353   2                      case KEY_WARM_DRY:
 354   2                              if(KEY_WARM_DRY != p_data->remote.key.keysta_pri)
 355   2                              {
 356   3                                      p_data->remote.key.keysta_pri = KEY_WARM_DRY;
 357   3                                      
 358   3                                      p_data->buzzer.normal_bee_on = ON;
 359   3                              
 360   3                                      
 361   3                                      p_data->remote.workmode.flag_work_warmdry = YES;
 362   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 363   3                              }
 364   2                              else
 365   2                              {
 366   3                                      p_data->buzzer.burn_bee_on = ON;
 367   3                              }
 368   2                              break;
 369   2                      case KEY_SWING:
 370   2                              /* only blow mode or warm mode and dry can enter this condition */
 371   2                              if(((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 372   2                                      || (WORKMODULE_WARM == p_data->remote.workmode.workmode_current)))
 373   2                              {
 374   3                                      p_data->buzzer.normal_bee_on = ON;
 375   3                                      if(OFF == p_data->remote.keyctrl.keystate_swing)
 376   3                                      {
 377   4                                              /* open swing page */
 378   4                                              p_data->remote.keyctrl.keystate_swing = ON;
 379   4                                      }
 380   3                                      else
 381   3                                      {
 382   4                                              /* close swing page */
 383   4                                              p_data->remote.keyctrl.keystate_swing = OFF;
 384   4                                      }
 385   3                              }
 386   2                              else
 387   2                              {
 388   3                                      p_data->buzzer.burn_bee_on = ON;
 389   3                              }
 390   2                              break;
 391   2                      case KEY_LIGHT:
 392   2                              p_data->buzzer.normal_bee_on = ON;
 393   2                              if(OFF == p_data->remote.keyctrl.keystate_light)
 394   2                              {
 395   3                                      p_data->remote.keyctrl.keystate_light = ON;
 396   3                              }
 397   2                              else
 398   2                              {
 399   3                                      p_data->remote.keyctrl.keystate_light = OFF;
 400   3                              }
 401   2                              break;
 402   2                      default:
 403   2                              break;
 404   2              }
 405   1              p_data->remote.key.keysta = KEY_RELEASE;
 406   1      }
 407          
 408          /*********************************************************************************************************
             -**************
 409          * Function Name: 
 410          * Description  : 
 411          * Arguments    : None
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 8   

 412          * Return Value : None
 413          **********************************************************************************************************
             -*************/
 414          void fml_ctrl_deal_automode(workmoduleflag* p_mode)                                                     //check
 415          {
 416   1              static switchstate       s_onetime  = RESET;
 417   1              static unsigned char s_time_dry_tmp = 0;
 418   1              static unsigned int  s_time_dry_min = 0;
 419   1              static switchstate       s_state    = RESET;
 420   1      
 421   1              if((YES == p_mode->flag_work_warmdry) || (YES == p_mode->flag_work_colddry))
 422   1              {
 423   2                      if(YES == p_mode->flag_work_warmdry)
 424   2                      {
 425   3                              if(WARM != s_state)
 426   3                              {
 427   4                                      s_onetime = RESET;
 428   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 429   4                              }
 430   3                              s_state = WARM;
 431   3                      }
 432   2                      else
 433   2                      {
 434   3                              if(COLD != s_state)
 435   3                              {
 436   4                                      s_onetime = RESET;
 437   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 438   4                              }
 439   3                              s_state = COLD;
 440   3                      }
 441   2                      if(YES == p_mode->flag_work_warmdry)
 442   2                      {
 443   3                              if((s_time_dry_min % (CLOCK_WARMDRY_WARM_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 444   3                                      < (CLOCK_WARMDRY_WARM_10MIN - CLOCK_DELAYTIMER_10S))
 445   3                              {
 446   4                                      p_mode->workmode_current = WORKMODULE_WARM;
 447   4                              }
 448   3                              else
 449   3                              {
 450   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 451   4                              }
 452   3                      }
 453   2                      else
 454   2                      {
 455   3                              if((s_time_dry_min % (CLOCK_COLDDRY_COLD_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 456   3                                      < CLOCK_COLDDRY_COLD_10MIN)
 457   3                              {
 458   4                                      p_mode->workmode_current = WORKMODULE_BLOW;
 459   4                              }
 460   3                              else
 461   3                              {
 462   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 463   4                              }
 464   3                      }               
 465   2                      if(RESET == s_onetime)
 466   2                      {
 467   3                              s_onetime = SET;
 468   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 469   3                      }
 470   2                      if(YES == CTRL_EXCEED_DELAY_TIMER(1, p_mode->workdelay_cyc, s_time_dry_tmp))
 471   2                      {
 472   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 9   

 473   3                              s_time_dry_min++;
 474   3                              if(s_time_dry_min >= CLOCK_WORKDRY_ALL_60MIN)
 475   3                              {
 476   4                                      p_mode->workmode_current = WORKMODULE_STANDBY;
 477   4                                      if(YES == p_mode->flag_work_warmdry)
 478   4                                      {       
 479   5                                              p_mode->flag_work_warmdry = NO;
 480   5                                      }
 481   4                                      else
 482   4                                      {
 483   5                                              p_mode->flag_work_colddry = NO;
 484   5                                      }
 485   4                              }
 486   3                      }
 487   2              }
 488   1              else
 489   1              {
 490   2                      s_state = RESET;
 491   2              }
 492   1      }
 493          
 494          /*********************************************************************************************************
             -**************
 495          * Function Name: 
 496          * Description  : 
 497          * Arguments    : None
 498          * Return Value : None
 499          **********************************************************************************************************
             -*************/
 500          void fml_ctrl_deal_mode(datall* p_data)
 501          {       
 502   1              static switchstate   s_onetime[2] = {STEP1, RESET};
 503   1              static unsigned char s_time_ptc_worktime = 0;
 504   1      
 505   1              fml_ctrl_deal_automode(&p_data->remote.workmode);
 506   1              switch(p_data->remote.workmode.workmode_current)
 507   1              {
 508   2                      case WORKMODULE_STANDBY:
 509   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 510   2                              {
 511   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 512   3                              }
 513   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 514   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 515   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 516   2                              p_data->remote.key.keysta_pri = KEY_STANDBY;
 517   2                              break;
 518   2                      case WORKMODULE_BLOW:
 519   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 520   2                              {
 521   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 522   3                              }
 523   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 524   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 525   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 526   2                              break;
 527   2                      case WORKMODULE_WARM:
 528   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)       ///< delay 10s
 529   2                              {
 530   3                                      if(ON == p_data->remote.keyctrl.keystate_move_target)                   ///< move target step
 531   3                                      {
 532   4                                              if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 10  

 533   4                                              {
 534   5                                                      p_data->remote.workmode.flag_workdelay_1s = RESET;
 535   5                                                      p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 536   5                                              }                                       
 537   4                                              p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 538   4                                      }
 539   3                                      else
 540   3                                      {
 541   4                                              p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;             ///< start from last step
 542   4                                      }
 543   3                              }               
 544   2                              if(p_data->remote.workmode.workdelay_1s >= CLOCK_DELAYTIMER_1S)
 545   2                              {
 546   3                                      if((OFF == p_data->remote.keyctrl.keystate_ptc_wait) 
 547   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))
 548   3                                      {
 549   4                                              p_data->remote.keyctrl.keystate_ptc   = ON;                     ///< restart ptc
 550   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 551   4                                      }
 552   3                              }
 553   2                              break;
 554   2                      case WORKMODULE_ABSORB:
 555   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 556   2                              {
 557   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 558   3                              }
 559   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 560   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 561   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 562   2                              break;
 563   2                      default:
 564   2                              break;
 565   2              }
 566   1              if(p_data->remote.keyctrl.keystate_ptc_pri != p_data->remote.keyctrl.keystate_ptc)
 567   1              {
 568   2                      if(ON == p_data->remote.keyctrl.keystate_ptc)
 569   2                      {
 570   3                              if(RESET == s_onetime[1])
 571   3                              {
 572   4                                      s_time_ptc_worktime = p_data->remote.workmode.workdelay_cyc;
 573   4                              }
 574   3                              s_onetime[1] = SET;
 575   3                      }
 576   2                      else
 577   2                      {
 578   3                              s_onetime[1] = RESET;
 579   3                      }
 580   2                      p_data->remote.keyctrl.keystate_ptc_pri = p_data->remote.keyctrl.keystate_ptc;  
 581   2              }
 582   1              else
 583   1              {
 584   2                      if(ON == p_data->remote.keyctrl.keystate_ptc_pri)
 585   2                      {
 586   3                              if(YES == CTRL_EXCEED_DELAY_TIMER(0, p_data->remote.workmode.workdelay_cyc, s_time_ptc_worktime))
 587   3                              {
 588   4                                      p_data->remote.keyctrl.keystate_ptc_delay = YES;
 589   4                              }
 590   3                      }
 591   2                      else
 592   2                      {
 593   3                              p_data->remote.keyctrl.keystate_ptc_delay = NO;
 594   3                      }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 11  

 595   2              }
 596   1      }
 597          
 598          /*********************************************************************************************************
             -**************
 599          * Function Name: 
 600          * Description  : 
 601          * Arguments    : None
 602          * Return Value : None
 603          **********************************************************************************************************
             -*************/
 604          void fml_ctrl_deal_motor(datall* p_data)
 605          {
 606   1              static switchstate s_step = STEP1;
 607   1      
 608   1              switch(p_data->remote.workmode.workmode_current)
 609   1              {
 610   2                      case WORKMODULE_STANDBY:
 611   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 612   2                              {
 613   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 614   3      
 615   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 616   3                              }
 617   2                              else
 618   2                              {
 619   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 620   3                                      {
 621   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;
 622   4                                      }
 623   3                              }
 624   2                              break;  
 625   2                      case WORKMODULE_BLOW:
 626   2                      case WORKMODULE_WARM:
 627   2                              if((p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 628   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))
 629   2                              {
 630   3                                      if(RESET == p_data->remote.keyctrl.keystate_enter_swing)
 631   3                                      {
 632   4                                              s_step = STEP1;
 633   4                                              p_data->remote.keyctrl.keystate_enter_swing = SET;
 634   4                                              p_data->motor.blow_target_step     = TARGET_STEP_BLOW;
 635   4                                              p_data->motor.blow_motor_step_pri  = TARGET_STEP_BLOW;
 636   4                                              p_data->motor.blow_target_step_pri = TARGET_LOW_SWING;
 637   4                                      }
 638   3                                      else
 639   3                                      {
 640   4                                              if(ON == p_data->remote.keyctrl.keystate_swing)
 641   4                                              {
 642   5                                                      switch(s_step)
 643   5                                                      {
 644   6                                                              case STEP1:
 645   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 646   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 647   6                                                                      {
 648   7                                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 649   7                                                                              s_step = STEP2;
 650   7                                                                      }
 651   6                                                                      break;
 652   6                                                              case STEP2:
 653   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 654   6                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 12  

 655   6                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 656   6                                                                      {
 657   7                                                                              s_step = STEP3;
 658   7                                                                      }
 659   6                                                                      break;
 660   6                                                              case STEP3:
 661   6                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 662   6                                                                      if(p_data->motor.blow_motor_step == TARGET_HIGH_SWING)
 663   6                                                                      {
 664   7                                                                              p_data->motor.blow_target_step          = TARGET_LOW_SWING;
 665   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;             ///< save target step
 666   7                                                                      }
 667   6                                                                      else if(p_data->motor.blow_motor_step == TARGET_LOW_SWING)
 668   6                                                                      {
 669   7                                                                              p_data->motor.blow_target_step          = TARGET_HIGH_SWING;
 670   7                                                                              p_data->motor.blow_target_step_pri      = TARGET_HIGH_SWING;    ///< save target step
 671   7                                                                      }
 672   6                                                                      else
 673   6                                                                      {
 674   7                                                                              if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 675   7                                                                              {
 676   8                                                                                      p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 677   8                                                                              }
 678   7                                                                      }
 679   6                                                                      break;
 680   6                                                              default:
 681   6                                                                      break;
 682   6                                                      }
 683   5                                              }
 684   4                                              else
 685   4                                              {
 686   5                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 687   5                                              }
 688   4      
 689   4                                              if(YES == MOTOR_CHK_MOVE_TO_TARGET)
 690   4                                              {
 691   5                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 692   5                                              }
 693   4                                      }
 694   3                              }
 695   2                              break;
 696   2                      case WORKMODULE_ABSORB:
 697   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 698   2                              {
 699   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 700   3      
 701   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 702   3                              }
 703   2                              else
 704   2                              {
 705   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 706   3                                      {
 707   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;    
 708   4                                      }
 709   3                              }
 710   2                              break;
 711   2                      default:
 712   2                              break;
 713   2              }
 714   1      }
 715          
 716          /*********************************************************************************************************
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 13  

             -**************
 717          * Function Name: 
 718          * Description  : 
 719          * Arguments    : None
 720          * Return Value : None
 721          **********************************************************************************************************
             -*************/
 722          void fml_ctrl_deal_fan(datall* p_data)
 723          {
 724   1              switch(p_data->remote.workmode.workmode_current)
 725   1              {
 726   2                      case WORKMODULE_STANDBY:
 727   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 728   2                              {
 729   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 730   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 731   3                              }
 732   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 733   2                              break;
 734   2                      case WORKMODULE_BLOW:
 735   2                      case WORKMODULE_WARM:
 736   2                              if((ON == p_data->remote.keyctrl.keystate_move_target) ///< move to target step.
 737   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))  ///< need open blow fan when work swing func.
 738   2                              {
 739   3                                      p_data->remote.workmode.flag_workdelay_1s = SET;
 740   3                                      p_data->remote.keyctrl.keystate_fan_blow  = ON;
 741   3                              }
 742   2                              else
 743   2                              {
 744   3                                      if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 745   3                                      {
 746   4                                              p_data->remote.workmode.flag_workdelay_1s       = RESET;
 747   4                                              p_data->remote.keyctrl.keystate_move_target = OFF;
 748   4                                              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 749   4                                      }                                                               
 750   3                              }
 751   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 752   2                              break;
 753   2                      case WORKMODULE_ABSORB:
 754   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 755   2                              {
 756   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 757   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 758   3                                      p_data->remote.keyctrl.keystate_fan_absorb      = ON;
 759   3                              }
 760   2                              break;
 761   2                      default:
 762   2                              break;
 763   2              }
 764   1      }
 765          
 766          /*********************************************************************************************************
             -**************
 767          * Function Name: 
 768          * Description  : 
 769          * Arguments    : None
 770          * Return Value : None
 771          **********************************************************************************************************
             -*************/
 772          void fml_ctrl_deal_swing(datall* p_data)
 773          {
 774   1              switch(p_data->remote.workmode.workmode_current)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 14  

 775   1              {
 776   2                      case WORKMODULE_STANDBY:
 777   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 778   2                              p_data->remote.keyctrl.keystate_swing      = OFF;
 779   2                              break;
 780   2                      case WORKMODULE_BLOW:
 781   2                      case WORKMODULE_WARM:
 782   2                              if(p_data->remote.keyctrl.keystate_swing_pri != p_data->remote.keyctrl.keystate_swing)
 783   2                              {
 784   3                                      p_data->remote.keyctrl.keystate_swing_pri = p_data->remote.keyctrl.keystate_swing;
 785   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)                                         //?
 786   3                                      {
 787   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 788   4                                      }
 789   3                                      p_data->remote.keyctrl.keystate_enter_swing = SET;
 790   3                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;     ///< move to last step
 791   3                              }
 792   2                              else
 793   2                              {
 794   3                                      if((ON == p_data->remote.keyctrl.keystate_swing)                                ///< open swing func
 795   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))         ///< move to target step
 796   3                                      {
 797   4                                              p_data->remote.keyctrl.keystate_open_swing = ON;
 798   4                                      }
 799   3                                      else
 800   3                                      {
 801   4                                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 802   4                                      }
 803   3                              }
 804   2                              break;
 805   2                      case WORKMODULE_ABSORB:
 806   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 807   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 808   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 809   2                              {
 810   3                                      p_data->remote.keyctrl.keystate_swing      = OFF;
 811   3                              }
 812   2                              break;
 813   2                      default:
 814   2                              break;
 815   2              }
 816   1      }
 817          
 818          /*********************************************************************************************************
             -**************
 819          * Function Name: 
 820          * Description  : 
 821          * Arguments    : None
 822          * Return Value : None
 823          **********************************************************************************************************
             -*************/
 824          void fml_ctrl_deal_timer(datall* p_data)
 825          {
 826   1              if(REMOTE != p_data->keytype)
 827   1                      return;
 828   1              
 829   1              hal_timer_mode_deal(&p_data->remote.workmode);
 830   1      }
 831          /*********************************************************************************************************
             -**************
 832          * Function Name: 
 833          * Description  : 
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 15  

 834          * Arguments    : None
 835          * Return Value : None
 836          **********************************************************************************************************
             -*************/
 837          void fml_ctrl_key_logic(datall* p_data)
 838          {
 839   1              #ifdef XY_SYS_TEST_MODE
 840   1                      if(YES == p_data->testmode)
 841   1                              return;
 842   1              #endif
 843   1              
 844   1              fml_ctrl_recv_display(p_data);                                                  ///< recive remote key value
 845   1              if(REMOTE != p_data->keytype)
 846   1                      return;
 847   1      
 848   1              fml_ctrl_deal_key(p_data);                                                              ///< analysis key value 
 849   1              fml_ctrl_deal_mode(p_data);                                                             ///< control relay by diff mode
 850   1              fml_ctrl_deal_motor(p_data);                                                    ///< update motor step
 851   1              fml_ctrl_deal_swing(p_data);                                                    ///< control swing func
 852   1              fml_ctrl_deal_fan(p_data);                                                              ///< control fan machine
 853   1              fml_ctrl_chk_error(p_data);                                                             ///< check data result legal
 854   1      }
 855          
 856          /*********************************************************************************************************
             -**************
 857          * Function Name: 
 858          * Description  : 
 859          * Arguments    : None
 860          * Return Value : None
 861          **********************************************************************************************************
             -*************/
 862          void fml_ctrl_work_time(datall* p_data)
 863          {
 864   1              static workmodule  s_workmode = WORKMODULE_STANDBY;
 865   1              static unsigned int  s_work_min = 0;
 866   1      
 867   1              if(REMOTE != p_data->keytype)
 868   1                      return;
 869   1              
 870   1              if(s_workmode != p_data->remote.workmode.workmode_current)
 871   1              {
 872   2                      s_workmode = p_data->remote.workmode.workmode_current;
 873   2                      s_work_min = 0;
 874   2              }       
 875   1              switch(p_data->remote.workmode.workmode_current)
 876   1              {
 877   2                      case WORKMODULE_STANDBY:
 878   2                              s_work_min = 0;
 879   2                              break;
 880   2                      case WORKMODULE_BLOW:
 881   2                      case WORKMODULE_WARM:
 882   2                      case WORKMODULE_ABSORB:
 883   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 884   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 885   2                              {
 886   3                                      s_work_min++;
 887   3                              }
 888   2                              break;
 889   2                      default:
 890   2                              break;
 891   2              }       
 892   1              if(s_work_min >= CLOCK_WORKTIME_120MIN)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/27/2021 10:41:03 PAGE 16  

 893   1              {
 894   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 895   2              }
 896   1      }
 897          
 898          /*********************************************************************************************************
             -**************
 899          * Function Name: 
 900          * Description  : 
 901          * Arguments    : None
 902          * Return Value : None
 903          **********************************************************************************************************
             -*************/
 904          void fml_ctrl_deal_alarm(datall* p_data)
 905          {
 906   1              if((p_data->temperature.value >= ALARM_HIGH_TEMP))
 907   1              {
 908   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 909   2              }
 910   1      }
 911          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3912    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =     12      36
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
