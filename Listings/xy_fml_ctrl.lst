C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE XY_FML_CTRL
OBJECT MODULE PLACED IN .\Objects\xy_fml_ctrl.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE 02_FML\xy_fml_ctrl.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\01_APL;.\
                    -02_FML;.\03_HAL;.\04_SYS) DEBUG PRINT(.\Listings\xy_fml_ctrl.lst) OBJECT(.\Objects\xy_fml_ctrl.obj)

line level    source

   1          #include "xy_sys_headfile.h"
   2          
   3          /*********************************************************************************************************
             -**************
   4          * Function Name: 
   5          * Description  : 
   6          * Arguments    : None
   7          * Return Value : None
   8          **********************************************************************************************************
             -*************/
   9          void fml_ctrl_init_reg(void)
  10          {
  11   1              hal_port_init();
  12   1              hal_timer_Init();
  13   1              hal_serial_Init();
  14   1      }
  15          
  16          /*********************************************************************************************************
             -**************
  17          * Function Name: 
  18          * Description  : 
  19          * Arguments    : None
  20          * Return Value : None
  21          **********************************************************************************************************
             -*************/
  22          void fml_ctrl_init_data(datall* p_data)
  23          {
  24   1              p_data->remote.workmode.workmode_current        = WORKMODULE_DEFAULT;
  25   1              p_data->remote.keyctrl.keystate_light           = OFF;
  26   1              p_data->remote.keyctrl.keystate_swing           = OFF;
  27   1              p_data->remote.keyctrl.keystate_ptc             = OFF;
  28   1              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
  29   1              p_data->remote.keyctrl.keystate_fan_absorb      = OFF;
  30   1              p_data->remote.keyctrl.keystate_ptc_wait        = OFF;
  31   1      
  32   1              p_data->remote.keyctrl.keystate_swing_pri       = OFF;
  33   1              p_data->remote.keyctrl.keystate_enter_swing = RESET;
  34   1              p_data->remote.keyctrl.keystate_dry_wet         = DRY;
  35   1              p_data->remote.keyctrl.keystate_dry_wet_pri = DRY;
  36   1      
  37   1              p_data->remote.workmode.flag_workdelay_1s       = SET;
  38   1              p_data->remote.workmode.flag_workdelay_10s      = SET;
  39   1              p_data->remote.workmode.workdelay_1s            = CLOCK_DELAYTIMER_0S;
  40   1              p_data->remote.workmode.workdelay_10s           = CLOCK_DELAYTIMER_10S;
  41   1      
  42   1              p_data->remote.workmode.flag_work_colddry       = NO;
  43   1              p_data->remote.workmode.flag_work_warmdry       = NO;
  44   1      
  45   1              p_data->uart.send_data                                          = 0;
  46   1              p_data->display.disp_icon_data                          = 0;
  47   1      }
  48          
  49          /*********************************************************************************************************
             -**************
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 2   

  50          * Function Name: 
  51          * Description  : 
  52          * Arguments    : None
  53          * Return Value : None
  54          **********************************************************************************************************
             -*************/
  55          void fml_ctrl_chk_error(datall* p_data)                                                 //检测步进电机、互锁情况
  56          {
  57   1              datacommon       err;
  58   1              unsigned int motor[4] = {0};
  59   1              switchstate  state[3] = {0};
  60   1      
  61   1              motor[0] = p_data->motor.blow_target_step;
  62   1      //      motor[1] = p_data->motor.absorb_target_step;
  63   1              motor[2] = p_data->motor.blow_motor_step;
  64   1      //      motor[3] = p_data->motor.absorb_motor_step;
  65   1              state[0] = p_data->remote.keyctrl.keystate_fan_blow;
  66   1              state[1] = p_data->remote.keyctrl.keystate_fan_absorb;
  67   1              state[2] = p_data->remote.keyctrl.keystate_ptc;
  68   1              err.dat  = 0;
  69   1              if(YES == CTRL_CHECK_ERROR_NUMB_1(motor[0], motor[1], state[0], state[1], state[2]))
  70   1              {
  71   2                      p_data->motor.switch_target_step = RESET_STEP_ZERO;
  72   2                      err.bits.b0 = 1;
  73   2              }
  74   1      
  75   1              if(YES == CTRL_CHECK_ERROR_NUMB_2(motor[0], motor[1], state[0], state[1], state[2]))
  76   1              {
  77   2                      p_data->motor.blow_target_step = RESET_STEP_ZERO;
  78   2                      err.bits.b1 = 1;
  79   2              }
  80   1      
  81   1              if(YES == CTRL_CHECK_ERROR_NUMB_3(motor[0], motor[1], state[0], state[1], state[2]))
  82   1              {
  83   2                      p_data->motor.blow_target_step = RESET_STEP_ZERO;
  84   2                      err.bits.b2 = 1;
  85   2              }
  86   1      
  87   1              if(YES == CTRL_CHECK_ERROR_NUMB_4(motor[0], motor[1], state[0], state[1], state[2]))
  88   1              {
  89   2                      p_data->motor.switch_target_step = RESET_STEP_ZERO;
  90   2                      err.bits.b3 = 1;
  91   2              }
  92   1      
  93   1              if(YES == CTRL_CHECK_ERROR_NUMB_5(motor[0], motor[1], state[0], state[1], state[2]))
  94   1              {
  95   2                      p_data->motor.switch_target_step = RESET_STEP_ZERO;
  96   2                      err.bits.b4 = 1;
  97   2              }
  98   1      
  99   1              if(YES == CTRL_CHECK_ERROR_NUMB_6(motor[0], motor[1], state[0], state[1], state[2]))
 100   1              {
 101   2                      p_data->motor.blow_target_step = RESET_STEP_ZERO;
 102   2                      err.bits.b5 = 1;
 103   2              }
 104   1      
 105   1              if(YES == CTRL_CHECK_ERROR_NUMB_7(motor[0], motor[2], state[0], state[1], state[2]))
 106   1              {
 107   2                      if(p_data->motor.blow_motor_step && (ON == MOTOR_CHK_STEP_IS_LEGAL(p_data->motor.blow_motor_step)))
 108   2                      {
 109   3                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 110   3                      }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 3   

 111   2      
 112   2                      if(OFF == p_data->remote.keyctrl.keystate_open_swing)
 113   2                      {
 114   3                              p_data->remote.keyctrl.keystate_fan_blow = OFF;
 115   3                              err.bits.b6 = 1;        
 116   3                      }
 117   2              }
 118   1      
 119   1              if(YES == CTRL_CHECK_ERROR_NUMB_8(motor[1], motor[3], state[0], state[1], state[2]))
 120   1              {
 121   2                      p_data->remote.keyctrl.keystate_fan_blow = OFF;
 122   2                      err.bits.b7 = 1;
 123   2              }
 124   1      
 125   1              if(YES == CTRL_CHECK_ERROR_NUMB_9(motor[0], motor[1], state[0], state[1], state[2]))
 126   1              {
 127   2                      p_data->remote.keyctrl.keystate_fan_absorb = OFF;
 128   2                      err.bits.b8 = 1;
 129   2              }
 130   1      
 131   1              if(YES == CTRL_CHECK_ERROR_NUMB_A(motor[0], motor[1], state[0], state[1], state[2]))
 132   1              {
 133   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
 134   2                      err.bits.b9 = 1;
 135   2              }
 136   1      
 137   1              if(YES == CTRL_CHECK_ERROR_NUMB_B(motor[0], motor[1], state[0], state[1], state[2]))
 138   1              {
 139   2                      p_data->remote.keyctrl.keystate_ptc = OFF;
 140   2                      err.bits.b10 = 1;
 141   2              }
 142   1      
 143   1              p_data->error.dat = err.dat;
 144   1      }
 145          
 146          /*********************************************************************************************************
             -**************
 147          * Function Name: 
 148          * Description  : 
 149          * Arguments    : None
 150          * Return Value : None
 151          **********************************************************************************************************
             -*************/
 152          void fml_ctrl_icon_display(datall* p_data)
 153          {       
 154   1              #ifdef XY_SYS_TEST_MODE
 155   1                      if(YES == p_data->testmode)
 156   1                              return;
 157   1              #endif
 158   1              
 159   1              if(REMOTE != p_data->keytype)
 160   1                      return;
 161   1              
 162   1              switch(p_data->remote.workmode.workmode_current)
 163   1              {
 164   2                      case WORKMODULE_STANDBY:
 165   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)                //workdelay!
 166   2                              {
 167   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_STANDBY;
 168   3                              }
 169   2                              else
 170   2                              {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 4   

 171   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 172   3                              }
 173   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 174   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 175   2                              break;
 176   2                      case WORKMODULE_BLOW:
 177   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;
 178   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 179   2                              p_data->display.disp_icon_blow      = SYM_BLOW_ON;
 180   2                              break;
 181   2                      case WORKMODULE_WARM:
 182   2                              p_data->display.disp_icon_warm      = SYM_WARM_ON;
 183   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 184   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 185   2                              break;
 186   2                      case WORKMODULE_ABSORB:
 187   2                              if(p_data->remote.workmode.workdelay_10s < CLOCK_DELAYTIMER_10S)
 188   2                              {
 189   3                                      p_data->display.disp_icon_warm = SYM_WARM_TWINKLE_ABSORB;
 190   3                              }
 191   2                              else
 192   2                              {
 193   3                                      p_data->display.disp_icon_warm = SYM_WARM_OFF;
 194   3                              }       
 195   2                              p_data->display.disp_icon_absorb  = SYM_ABSORB_ON;
 196   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 197   2                              break;
 198   2                      default:
 199   2                              p_data->display.disp_icon_warm     = SYM_WARM_OFF;                              
 200   2                              p_data->display.disp_icon_absorb = SYM_ABSORB_OFF;
 201   2                              p_data->display.disp_icon_blow     = SYM_BLOW_OFF;
 202   2                              break;
 203   2              }
 204   1      }
 205          
 206          /*********************************************************************************************************
             -**************
 207          * Function Name: 
 208          * Description  : 
 209          * Arguments    : None
 210          * Return Value : None
 211          **********************************************************************************************************
             -*************/
 212          void fml_ctrl_recv_old_version(datall* p_data)
 213          {
 214   1              unsigned char i;
 215   1              unsigned char temp_sum = 0;
 216   1              unsigned char buffer[sizeof(p_data->uart.rec_uart1_dat)] = {0};
 217   1      
 218   1              memcpy(buffer, p_data->uart.rec_uart1_dat, sizeof(buffer));
 219   1              memset(p_data->uart.rec_uart1_dat, 0, sizeof(buffer));
 220   1      
 221   1              for(i=0; i<5; i++)
 222   1              {
 223   2                      temp_sum += buffer[i];
 224   2              }
 225   1      
 226   1              if(temp_sum == buffer[i])                       ///< check data 
 227   1              {
 228   2                      p_data->remote.key.keyremote.dat = buffer[2] + (buffer[3]<<8);
 229   2      
 230   2                      if(p_data->remote.key.keyremote.bits.b0)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 5   

 231   2                      {
 232   3                              p_data->remote.key.keysta = KEY_LIGHT;
 233   3                      }
 234   2                      else if(p_data->remote.key.keyremote.bits.b1)
 235   2                      {
 236   3                              p_data->remote.key.keysta = KEY_BLOW;
 237   3                      }
 238   2                      else if(p_data->remote.key.keyremote.bits.b2)
 239   2                      {
 240   3                              p_data->remote.key.keysta = KEY_ABSORB;
 241   3                      }
 242   2                      else if(p_data->remote.key.keyremote.bits.b3)
 243   2                      {
 244   3                              p_data->remote.key.keysta = KEY_WARM;
 245   3                      }
 246   2                      else if(p_data->remote.key.keyremote.bits.b4)
 247   2                      {
 248   3                              p_data->remote.key.keysta = KEY_SWING;
 249   3                      }
 250   2                      else if(p_data->remote.key.keyremote.bits.b5)
 251   2                      {
 252   3                              p_data->remote.key.keysta = KEY_RAV;
 253   3                      }
 254   2                      else if(p_data->remote.key.keyremote.bits.b6)
 255   2                      {
 256   3                              p_data->remote.key.keysta = KEY_DRY_WET;
 257   3                      }
 258   2                      else if(p_data->remote.key.keyremote.bits.b7)
 259   2                      {
 260   3                              p_data->remote.key.keysta = KEY_STANDBY;
 261   3                      }
 262   2                      else if(p_data->remote.key.keyremote.bits.b8)
 263   2                      {
 264   3                              p_data->remote.key.keysta = KEY_WARM_DRY;
 265   3                      }
 266   2      
 267   2                      if(KEY_RELEASE != p_data->remote.key.keysta)
 268   2                      {
 269   3                              if(TOUCH == p_data->keytype)
 270   3                              {
 271   4                                      memset(&p_data->touch, 0, sizeof(p_data->touch));
 272   4                                      fml_ctrl_init_data(p_data);
 273   4                                      p_data->keytype = REMOTE;
 274   4                              }
 275   3                      }
 276   2      
 277   2                      p_data->temperature.value = buffer[4];
 278   2              }
 279   1      }
 280          
 281          /*********************************************************************************************************
             -**************
 282          * Function Name: 
 283          * Description  : 
 284          * Arguments    : None
 285          * Return Value : None
 286          **********************************************************************************************************
             -*************/
 287          void fml_ctrl_recv_display(datall* p_data)
 288          {
 289   1              if(p_data->uart.rec_uart1_ok)
 290   1              {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 6   

 291   2                      p_data->uart.rec_uart1_ok = 0;
 292   2                      fml_ctrl_recv_old_version(p_data);                      ///< old version(only use remote key)
 293   2              }
 294   1      }
 295          
 296          /*********************************************************************************************************
             -**************
 297          * Function Name: 
 298          * Description  : 
 299          * Arguments    : None
 300          * Return Value : None
 301          **********************************************************************************************************
             -*************/
 302          void fml_ctrl_deal_key(datall* p_data)
 303          {       
 304   1              switch(p_data->remote.key.keysta)
 305   1              {
 306   2                      case KEY_STANDBY:
 307   2                              if(KEY_STANDBY != p_data->remote.key.keysta_pri)
 308   2                              {
 309   3                                      p_data->remote.key.keysta_pri = KEY_STANDBY;
 310   3      
 311   3                                      p_data->buzzer.normal_bee_on = ON;
 312   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
 313   3      
 314   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 315   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 316   3                              }
 317   2                              else
 318   2                              {
 319   3                                      p_data->buzzer.burn_bee_on = ON;
 320   3                              }
 321   2                              break;
 322   2                      case KEY_BLOW:
 323   2                              if(KEY_BLOW != p_data->remote.key.keysta_pri)
 324   2                              {
 325   3                                      p_data->remote.key.keysta_pri = KEY_BLOW;
 326   3      
 327   3                                      p_data->buzzer.normal_bee_on = ON;
 328   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_BLOW;
 329   3      
 330   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 331   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 332   3                              }
 333   2                              else
 334   2                              {
 335   3                                      p_data->buzzer.burn_bee_on = ON;
 336   3                              }
 337   2                              break;
 338   2                      case KEY_ABSORB:
 339   2                              if(KEY_ABSORB != p_data->remote.key.keysta_pri)
 340   2                              {
 341   3                                      p_data->remote.key.keysta_pri = KEY_ABSORB;
 342   3                                      
 343   3                                      p_data->buzzer.normal_bee_on = ON;
 344   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_ABSORB;
 345   3      
 346   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 347   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 348   3                              }
 349   2                              else
 350   2                              {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 7   

 351   3                                      p_data->buzzer.burn_bee_on = ON;
 352   3                              }
 353   2                              break;
 354   2                      case KEY_WARM:
 355   2                              if(KEY_WARM != p_data->remote.key.keysta_pri)                                   
 356   2                              {
 357   3                                      p_data->remote.key.keysta_pri = KEY_WARM;
 358   3      
 359   3                                      p_data->buzzer.normal_bee_on = ON;
 360   3                                      p_data->remote.workmode.workmode_current = WORKMODULE_WARM;
 361   3      
 362   3                                      p_data->remote.workmode.flag_work_warmdry = NO;
 363   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 364   3                              }
 365   2                              else
 366   2                              {
 367   3                                      p_data->buzzer.burn_bee_on = ON;
 368   3                              }
 369   2                              break;
 370   2                      case KEY_WARM_DRY:
 371   2                              if(KEY_WARM_DRY != p_data->remote.key.keysta_pri)
 372   2                              {
 373   3                                      p_data->remote.key.keysta_pri = KEY_WARM_DRY;
 374   3                                      
 375   3                                      p_data->buzzer.normal_bee_on = ON;
 376   3                                      //p_data->remote.workmode.workmode_cur = WORKMODULE_WARM;
 377   3                                      
 378   3                                      p_data->remote.workmode.flag_work_warmdry = YES;
 379   3                                      p_data->remote.workmode.flag_work_colddry = NO;
 380   3                                      if(WET == p_data->remote.keyctrl.keystate_dry_wet)
 381   3                                      {
 382   4                                              /* enter dry mode */
 383   4                                              p_data->remote.keyctrl.keystate_dry_wet = DRY;
 384   4                                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 385   4                                      }
 386   3                              }
 387   2                              else
 388   2                              {
 389   3                                      p_data->buzzer.burn_bee_on = ON;
 390   3                              }
 391   2                              break;
 392   2                      case KEY_SWING:
 393   2                              /* only blow mode or warm mode and dry can enter this condition */
 394   2                              if(((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 395   2                                      || (WORKMODULE_WARM == p_data->remote.workmode.workmode_current)))
 396   2                              {
 397   3                                      p_data->buzzer.normal_bee_on = ON;
 398   3                                      if(OFF == p_data->remote.keyctrl.keystate_swing)
 399   3                                      {
 400   4                                              /* open swing page */
 401   4                                              p_data->remote.keyctrl.keystate_swing = ON;
 402   4                                      }
 403   3                                      else
 404   3                                      {
 405   4                                              /* close swing page */
 406   4                                              p_data->remote.keyctrl.keystate_swing = OFF;
 407   4                                      }
 408   3                              }
 409   2                              else
 410   2                              {
 411   3                                      p_data->buzzer.burn_bee_on = ON;
 412   3                              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 8   

 413   2                              break;
 414   2                      case KEY_LIGHT:
 415   2                              p_data->buzzer.normal_bee_on = ON;
 416   2                              if(OFF == p_data->remote.keyctrl.keystate_light)
 417   2                              {
 418   3                                      p_data->remote.keyctrl.keystate_light = ON;
 419   3                              }
 420   2                              else
 421   2                              {
 422   3                                      p_data->remote.keyctrl.keystate_light = OFF;
 423   3                              }
 424   2                              break;
 425   2                              if((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 426   2                                      || ((WORKMODULE_WARM == p_data->remote.workmode.workmode_current) 
 427   2                                              && (NO == p_data->remote.workmode.flag_work_warmdry)))
 428   2                              {
 429   3                                      p_data->buzzer.normal_bee_on = ON;
 430   3      
 431   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 432   3                                      if(WET == p_data->remote.keyctrl.keystate_dry_wet)
 433   3                                      {
 434   4                                              /* enter dry mode */
 435   4                                              p_data->remote.keyctrl.keystate_dry_wet = DRY;
 436   4                                      }
 437   3                                      else
 438   3                                      {
 439   4                                              /* enter wet mode */
 440   4                                              p_data->remote.keyctrl.keystate_dry_wet         = WET;
 441   4                                      }
 442   3                              }
 443   2                              else
 444   2                              {
 445   3                                      p_data->buzzer.burn_bee_on = ON;
 446   3                              }
 447   2                              break;
 448   2                      default:
 449   2                              break;
 450   2              }
 451   1              p_data->remote.key.keysta = KEY_RELEASE;
 452   1      }
 453          
 454          /*********************************************************************************************************
             -**************
 455          * Function Name: 
 456          * Description  : 
 457          * Arguments    : None
 458          * Return Value : None
 459          **********************************************************************************************************
             -*************/
 460          void fml_ctrl_deal_automode(workmoduleflag* p_mode)                                                     //check
 461          {
 462   1              static switchstate       s_onetime  = RESET;
 463   1              static unsigned char s_time_dry_tmp = 0;
 464   1              static unsigned int  s_time_dry_min = 0;
 465   1              static switchstate       s_state    = RESET;
 466   1      
 467   1              if((YES == p_mode->flag_work_warmdry) || (YES == p_mode->flag_work_colddry))
 468   1              {
 469   2                      if(YES == p_mode->flag_work_warmdry)
 470   2                      {
 471   3                              if(WARM != s_state)
 472   3                              {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 9   

 473   4                                      s_onetime = RESET;
 474   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 475   4                              }
 476   3                              s_state = WARM;
 477   3                      }
 478   2                      else
 479   2                      {
 480   3                              if(COLD != s_state)
 481   3                              {
 482   4                                      s_onetime = RESET;
 483   4                                      s_time_dry_min = CLOCK_DELAYTIMER_0S;
 484   4                              }
 485   3                              s_state = COLD;
 486   3                      }
 487   2                      if(YES == p_mode->flag_work_warmdry)
 488   2                      {
 489   3                              if((s_time_dry_min % (CLOCK_WARMDRY_WARM_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 490   3                                      < (CLOCK_WARMDRY_WARM_10MIN - CLOCK_DELAYTIMER_10S))
 491   3                              {
 492   4                                      p_mode->workmode_current = WORKMODULE_WARM;
 493   4                              }
 494   3                              else
 495   3                              {
 496   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 497   4                              }
 498   3                      }
 499   2                      else
 500   2                      {
 501   3                              if((s_time_dry_min % (CLOCK_COLDDRY_COLD_10MIN + CLOCK_WARMDRY_ABSORB_5MIN)) 
 502   3                                      < CLOCK_COLDDRY_COLD_10MIN)
 503   3                              {
 504   4                                      p_mode->workmode_current = WORKMODULE_BLOW;
 505   4                              }
 506   3                              else
 507   3                              {
 508   4                                      p_mode->workmode_current = WORKMODULE_ABSORB;
 509   4                              }
 510   3                      }               
 511   2                      if(RESET == s_onetime)
 512   2                      {
 513   3                              s_onetime = SET;
 514   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 515   3                      }
 516   2                      if(YES == CTRL_EXCEED_DELAY_TIMER(1, p_mode->workdelay_cyc, s_time_dry_tmp))
 517   2                      {
 518   3                              s_time_dry_tmp = p_mode->workdelay_cyc;
 519   3                              s_time_dry_min++;
 520   3                              if(s_time_dry_min >= CLOCK_WORKDRY_ALL_60MIN)
 521   3                              {
 522   4                                      p_mode->workmode_current = WORKMODULE_STANDBY;
 523   4                                      if(YES == p_mode->flag_work_warmdry)
 524   4                                      {       
 525   5                                              p_mode->flag_work_warmdry = NO;
 526   5                                      }
 527   4                                      else
 528   4                                      {
 529   5                                              p_mode->flag_work_colddry = NO;
 530   5                                      }
 531   4                              }
 532   3                      }
 533   2              }
 534   1              else
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 10  

 535   1              {
 536   2                      s_state = RESET;
 537   2              }
 538   1      }
 539          
 540          /*********************************************************************************************************
             -**************
 541          * Function Name: 
 542          * Description  : 
 543          * Arguments    : None
 544          * Return Value : None
 545          **********************************************************************************************************
             -*************/
 546          void fml_ctrl_deal_mode(datall* p_data)
 547          {       
 548   1              static switchstate   s_onetime[2] = {STEP1, RESET};
 549   1              static unsigned char s_timecount_cur = 0, s_timecount_pri = 0;
 550   1              static unsigned char s_time_ptc_worktime = 0;
 551   1              
 552   1              fml_ctrl_deal_automode(&p_data->remote.workmode);
 553   1              switch(p_data->remote.workmode.workmode_current)
 554   1              {
 555   2                      case WORKMODULE_STANDBY:
 556   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 557   2                              {
 558   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 559   3                              }
 560   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 561   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 562   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 563   2                              p_data->remote.key.keysta_pri = KEY_STANDBY;    
 564   2                              break;
 565   2                      case WORKMODULE_BLOW:
 566   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 567   2                              {
 568   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 569   3                              }
 570   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 571   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 572   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 573   2      
 574   2                              if(p_data->remote.keyctrl.keystate_dry_wet_pri != p_data->remote.keyctrl.keystate_dry_wet)
 575   2                              {
 576   3                                      p_data->remote.keyctrl.keystate_dry_wet_pri = p_data->remote.keyctrl.keystate_dry_wet;
 577   3                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 578   3                              }
 579   2                              break;
 580   2                      case WORKMODULE_WARM:
 581   2                              if(p_data->remote.keyctrl.keystate_dry_wet_pri != p_data->remote.keyctrl.keystate_dry_wet)
 582   2                              {
 583   3                                      p_data->remote.keyctrl.keystate_dry_wet_pri = p_data->remote.keyctrl.keystate_dry_wet;
 584   3                                      
 585   3                                      if(STEP2 == s_onetime[0])
 586   3                                      {
 587   4                                              s_onetime[0] = STEP3;
 588   4                                              s_timecount_pri = s_timecount_cur;                      ///< ready to judge
 589   4                                      }
 590   3                                      
 591   3                                      if(YES == p_data->remote.keyctrl.keystate_ptc_delay)                    ///< restart cal time diff
 592   3                                      {
 593   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;    
 594   4                                              s_timecount_cur = p_data->remote.workmode.workdelay_cyc;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 11  

 595   4                                              s_onetime[0] = STEP2;
 596   4                                              p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 597   4                                      }
 598   3                                      
 599   3                                      p_data->remote.keyctrl.keystate_ptc      = OFF;
 600   3                                      p_data->remote.keyctrl.keystate_ptc_wait = ON;                  ///< change dry and wet start delay 10s
 601   3                              }
 602   2                              else
 603   2                              {
 604   3                                      if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)       ///< delay 10s
 605   3                                      {
 606   4                                              if(ON == p_data->remote.keyctrl.keystate_move_target)                   ///< move target step
 607   4                                              {
 608   5                                                      if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
 609   5                                                      {
 610   6                                                              p_data->remote.workmode.flag_workdelay_1s = RESET;
 611   6                                                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 612   6                                                      }
 613   5                                                      p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 614   5                                              }
 615   4                                              else
 616   4                                              {
 617   5                                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;             ///< start from last step
 618   5                                              }
 619   4                                      }
 620   3                                      else
 621   3                                      {
 622   4                                              if(STEP3 == s_onetime[0])
 623   4                                              {
 624   5                                                      if(ON == p_data->remote.keyctrl.keystate_ptc_wait)
 625   5                                                      {
 626   6                                                              if(NO == CTRL_EXCEED_DELAY_TIMER(10, s_timecount_cur, s_timecount_pri))
 627   6                                                              {
 628   7                                                                      p_data->remote.workmode.flag_workdelay_1s = SET;
 629   7                                                                      p_data->remote.keyctrl.keystate_ptc_wait = OFF;
 630   7                                                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 631   7                                                                      p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_1S;
 632   7                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 633   7                                                              }
 634   6                                                      }
 635   5                                              }
 636   4                                      }
 637   3                              }
 638   2                              
 639   2                              if(p_data->remote.workmode.workdelay_1s >= CLOCK_DELAYTIMER_1S)
 640   2                              {
 641   3                                      if((OFF == p_data->remote.keyctrl.keystate_ptc_wait) 
 642   3                              //              && (YES == MOTOR_CHK_MOVE_TO_TARGET))
 643   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))
 644   3                                      {
 645   4                                              p_data->remote.keyctrl.keystate_ptc   = ON;                     ///< restart ptc
 646   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 647   4                                      }
 648   3                              }
 649   2                              break;
 650   2                      case WORKMODULE_ABSORB:
 651   2                              if(YES == p_data->remote.keyctrl.keystate_ptc_delay)
 652   2                              {
 653   3                                      p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_0S;
 654   3                              }
 655   2                              p_data->remote.keyctrl.keystate_ptc = OFF;
 656   2                              p_data->remote.workmode.flag_workdelay_1s = RESET;
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 12  

 657   2                              p_data->remote.workmode.workdelay_1s = CLOCK_DELAYTIMER_0S;
 658   2                              break;
 659   2                      default:
 660   2                              break;
 661   2              }
 662   1              if(p_data->remote.keyctrl.keystate_ptc_pri != p_data->remote.keyctrl.keystate_ptc)
 663   1              {
 664   2                      if(ON == p_data->remote.keyctrl.keystate_ptc)
 665   2                      {
 666   3                              if(RESET == s_onetime[1])
 667   3                              {
 668   4                                      s_time_ptc_worktime = p_data->remote.workmode.workdelay_cyc;
 669   4                              }
 670   3                              s_onetime[1] = SET;
 671   3                      }
 672   2                      else
 673   2                      {
 674   3                              s_onetime[1] = RESET;
 675   3                      }
 676   2                      p_data->remote.keyctrl.keystate_ptc_pri = p_data->remote.keyctrl.keystate_ptc;  
 677   2              }
 678   1              else
 679   1              {
 680   2                      if(ON == p_data->remote.keyctrl.keystate_ptc_pri)
 681   2                      {
 682   3                              if(YES == CTRL_EXCEED_DELAY_TIMER(0, p_data->remote.workmode.workdelay_cyc, s_time_ptc_worktime))
 683   3                              {
 684   4                                      p_data->remote.keyctrl.keystate_ptc_delay = YES;
 685   4                              }
 686   3                      }
 687   2                      else
 688   2                      {
 689   3                              p_data->remote.keyctrl.keystate_ptc_delay = NO;
 690   3                      }
 691   2              }
 692   1      }
 693          /*********************************************************************************************************
             -**************
 694          * Function Name: 
 695          * Description  : 
 696          * Arguments    : None
 697          * Return Value : None
 698          **********************************************************************************************************
             -*************/
 699          void fml_ctrl_deal_motor(datall* p_data)
 700          {
 701   1              static switchstate s_step = STEP1;
 702   1      
 703   1              switch(p_data->remote.workmode.workmode_current)
 704   1              {
 705   2                      case WORKMODULE_STANDBY:
 706   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 707   2                              {
 708   3                                      p_data->motor.blow_target_step   = RESET_STEP_ZERO;
 709   3                                      p_data->motor.switch_target_step = RESET_STEP_ZERO;
 710   3      
 711   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 712   3                                      p_data->remote.keyctrl.keystate_dry_wet         = DRY;
 713   3                              }
 714   2                              else
 715   2                              {
 716   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 13  

 717   3                                      {
 718   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;
 719   4                                      }
 720   3                              }
 721   2                              break;
 722   2                      case WORKMODULE_BLOW:
 723   2                      case WORKMODULE_WARM:
 724   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 725   2                              {
 726   3                                      if(DRY == p_data->remote.keyctrl.keystate_dry_wet)
 727   3                                      {
 728   4                                              if(RESET == p_data->remote.keyctrl.keystate_enter_swing)
 729   4                                              {
 730   5                                                      s_step = STEP1;
 731   5                                                      p_data->remote.keyctrl.keystate_enter_swing = SET;
 732   5                                                      p_data->motor.blow_target_step          = TARGET_STEP_BLOW;
 733   5                                                      p_data->motor.blow_motor_step_pri       = TARGET_STEP_BLOW;
 734   5                                                      p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;
 735   5                                              }
 736   4                                              else
 737   4                                              {
 738   5                                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 739   5                                                      {
 740   6                                                              switch(s_step)
 741   6                                                              {
 742   7                                                                      case STEP1:
 743   7                                                                              p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 744   7                                                                              if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 745   7                                                                              {
 746   8                                                                                      p_data->remote.keyctrl.keystate_move_target = ON;
 747   8                                                                                      s_step = STEP2;
 748   8                                                                              }
 749   7                                                                              break;
 750   7                                                                      case STEP2:
 751   7                                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 752   7                                                                              p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 753   7                                                                              if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 754   7                                                                              {
 755   8                                                                                      s_step = STEP3;
 756   8                                                                              }
 757   7                                                                              break;
 758   7                                                                      case STEP3:
 759   7                                                                              p_data->remote.keyctrl.keystate_move_target = ON;
 760   7                                                                              if(p_data->motor.blow_motor_step == TARGET_HIGH_SWING)
 761   7                                                                              {
 762   8                                                                                      p_data->motor.blow_target_step          = TARGET_LOW_SWING;
 763   8                                                                                      p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;             ///< save target step
 764   8                                                                              }
 765   7                                                                              else if(p_data->motor.blow_motor_step == TARGET_LOW_SWING)
 766   7                                                                              {
 767   8                                                                                      p_data->motor.blow_target_step          = TARGET_HIGH_SWING;
 768   8                                                                                      p_data->motor.blow_target_step_pri      = TARGET_HIGH_SWING;    ///< save target step
 769   8                                                                              }
 770   7                                                                              else
 771   7                                                                              {
 772   8                                                                                      if(p_data->motor.blow_target_step == p_data->motor.blow_motor_step)
 773   8                                                                                      {
 774   9                                                                                              p_data->motor.blow_target_step = p_data->motor.blow_target_step_pri;
 775   9                                                                                      }
 776   8                                                                              }
 777   7                                                                              break;
 778   7                                                                      default:
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 14  

 779   7                                                                              break;
 780   7                                                              }
 781   6                                                      }
 782   5                                                      else
 783   5                                                      {
 784   6                                                              p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;
 785   6                                                      }
 786   5                                              }
 787   4                                              p_data->motor.switch_target_step        = TARGET_STEP_SWITCH;
 788   4                                      }
 789   3                                      else
 790   3                                      {
 791   4                                              s_step = STEP1;
 792   4                                              p_data->motor.blow_target_step          = RESET_STEP_ZERO;
 793   4                                              p_data->motor.switch_target_step        = RESET_STEP_ZERO;
 794   4                                      }
 795   3                                      if(YES == MOTOR_CHK_MOVE_TO_TARGET)
 796   3                                      {
 797   4                                              p_data->remote.keyctrl.keystate_move_target = ON;
 798   4                                      }
 799   3                              }
 800   2                              break;
 801   2                      case WORKMODULE_ABSORB:
 802   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 803   2                              {
 804   3                                      p_data->motor.blow_target_step  = RESET_STEP_ZERO;
 805   3                                      p_data->motor.switch_target_step = RESET_STEP_ZERO;
 806   3      
 807   3                                      p_data->remote.keyctrl.keystate_enter_swing = RESET;
 808   3                                      p_data->remote.keyctrl.keystate_dry_wet         = DRY;
 809   3                              }
 810   2                              else
 811   2                              {
 812   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)
 813   3                                      {
 814   4                                              p_data->motor.blow_target_step  = p_data->motor.blow_motor_step_pri;
 815   4                                      }
 816   3                              }
 817   2                              break;
 818   2                      default:
 819   2                              break;
 820   2              }
 821   1      }
 822          
 823          /*********************************************************************************************************
             -**************
 824          * Function Name: 
 825          * Description  : 
 826          * Arguments    : None
 827          * Return Value : None
 828          **********************************************************************************************************
             -*************/
 829          void fml_ctrl_deal_fan(datall* p_data)
 830          {
 831   1              switch(p_data->remote.workmode.workmode_current)
 832   1              {
 833   2                      case WORKMODULE_STANDBY:
 834   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 835   2                              {
 836   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 837   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 838   3                              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 15  

 839   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 840   2                              break;
 841   2                      case WORKMODULE_BLOW:
 842   2                      case WORKMODULE_WARM:
 843   2                              if((ON == p_data->remote.keyctrl.keystate_move_target) ///< move to target step.
 844   2                                      || (ON == p_data->remote.keyctrl.keystate_open_swing))  ///< need open blow fan when work swing func.
 845   2                              {
 846   3                                      p_data->remote.workmode.flag_workdelay_1s = SET;
 847   3                                      p_data->remote.keyctrl.keystate_fan_blow  = ON;
 848   3                              }
 849   2                              else
 850   2                              {
 851   3                                      if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 852   3                                      {
 853   4                                              p_data->remote.workmode.flag_workdelay_1s       = RESET;
 854   4                                              p_data->remote.keyctrl.keystate_move_target = OFF;
 855   4                                              p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 856   4                                      }                                                               
 857   3                              }
 858   2                              p_data->remote.keyctrl.keystate_fan_absorb              = OFF;
 859   2                              break;
 860   2                      case WORKMODULE_ABSORB:
 861   2                              if(p_data->remote.workmode.workdelay_10s >= CLOCK_DELAYTIMER_10S)
 862   2                              {
 863   3                                      p_data->remote.keyctrl.keystate_fan_blow        = OFF;
 864   3                                      p_data->remote.keyctrl.keystate_move_target = OFF;
 865   3                                      p_data->remote.keyctrl.keystate_fan_absorb      = ON;
 866   3                              }
 867   2                              break;
 868   2                      default:
 869   2                              break;
 870   2              }
 871   1      }
 872          
 873          /*********************************************************************************************************
             -**************
 874          * Function Name: 
 875          * Description  : 
 876          * Arguments    : None
 877          * Return Value : None
 878          **********************************************************************************************************
             -*************/
 879          void fml_ctrl_deal_swing(datall* p_data)
 880          {
 881   1              switch(p_data->remote.workmode.workmode_current)
 882   1              {
 883   2                      case WORKMODULE_STANDBY:
 884   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 885   2                              p_data->remote.keyctrl.keystate_swing      = OFF;
 886   2                              break;
 887   2                      case WORKMODULE_BLOW:
 888   2                      case WORKMODULE_WARM:
 889   2                              if(p_data->remote.keyctrl.keystate_swing_pri != p_data->remote.keyctrl.keystate_swing)
 890   2                              {
 891   3                                      p_data->remote.keyctrl.keystate_swing_pri = p_data->remote.keyctrl.keystate_swing;
 892   3                                      if(ON == p_data->remote.keyctrl.keystate_swing)                                         //?
 893   3                                      {
 894   4                                              p_data->remote.workmode.workdelay_10s = CLOCK_DELAYTIMER_10S;
 895   4                                      }
 896   3                                      p_data->remote.keyctrl.keystate_enter_swing = SET;
 897   3                                      p_data->motor.blow_target_step = p_data->motor.blow_motor_step_pri;     ///< move to last step
 898   3                              }
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 16  

 899   2                              else
 900   2                              {
 901   3                                      if((ON == p_data->remote.keyctrl.keystate_swing)                                ///< open swing func
 902   3                                              && (ON == p_data->remote.keyctrl.keystate_move_target))         ///< move to target step
 903   3                                      {
 904   4                                              p_data->remote.keyctrl.keystate_open_swing = ON;
 905   4                                      }
 906   3                                      else
 907   3                                      {
 908   4                                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 909   4                                      }
 910   3                              }
 911   2                              break;
 912   2                      case WORKMODULE_ABSORB:
 913   2                              p_data->remote.keyctrl.keystate_open_swing = OFF;
 914   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 915   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 916   2                              {
 917   3                                      p_data->remote.keyctrl.keystate_swing      = OFF;
 918   3                              }
 919   2                              break;
 920   2                      default:
 921   2                              break;
 922   2              }
 923   1      }
 924          
 925          /*********************************************************************************************************
             -**************
 926          * Function Name: 
 927          * Description  : 
 928          * Arguments    : None
 929          * Return Value : None
 930          **********************************************************************************************************
             -*************/
 931          void fml_ctrl_deal_timer(datall* p_data)
 932          {
 933   1              if(REMOTE != p_data->keytype)
 934   1                      return;
 935   1              
 936   1              hal_timer_mode_deal(&p_data->remote.workmode);
 937   1      }
 938          /*********************************************************************************************************
             -**************
 939          * Function Name: 
 940          * Description  : 
 941          * Arguments    : None
 942          * Return Value : None
 943          **********************************************************************************************************
             -*************/
 944          void fml_ctrl_key_logic(datall* p_data)
 945          {
 946   1              #ifdef XY_SYS_TEST_MODE
 947   1                      if(YES == p_data->testmode)
 948   1                              return;
 949   1              #endif
 950   1              
 951   1              fml_ctrl_recv_display(p_data);                                                  ///< recive remote key value
 952   1              if(REMOTE != p_data->keytype)
 953   1                      return;
 954   1      
 955   1              fml_ctrl_deal_key(p_data);                                                              ///< analysis key value 
 956   1              fml_ctrl_deal_mode(p_data);                                                             ///< control relay by diff mode
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 17  

 957   1              fml_ctrl_deal_motor(p_data);                                                    ///< update motor step
 958   1              fml_ctrl_deal_swing(p_data);                                                    ///< control swing func
 959   1              fml_ctrl_deal_fan(p_data);                                                              ///< control fan machine
 960   1              fml_ctrl_chk_error(p_data);                                                             ///< check data result legal
 961   1      }
 962          
 963          /*********************************************************************************************************
             -**************
 964          * Function Name: 
 965          * Description  : 
 966          * Arguments    : None
 967          * Return Value : None
 968          **********************************************************************************************************
             -*************/
 969          void fml_ctrl_work_time(datall* p_data)
 970          {
 971   1              static workmodule  s_workmode = WORKMODULE_STANDBY;
 972   1              static unsigned int  s_work_min = 0;
 973   1      
 974   1              if(REMOTE != p_data->keytype)
 975   1                      return;
 976   1              
 977   1              if(s_workmode != p_data->remote.workmode.workmode_current)
 978   1              {
 979   2                      s_workmode = p_data->remote.workmode.workmode_current;
 980   2                      s_work_min = 0;
 981   2              }       
 982   1              switch(p_data->remote.workmode.workmode_current)
 983   1              {
 984   2                      case WORKMODULE_STANDBY:
 985   2                              s_work_min = 0;
 986   2                              break;
 987   2                      case WORKMODULE_BLOW:
 988   2                      case WORKMODULE_WARM:
 989   2                      case WORKMODULE_ABSORB:
 990   2                              if((NO == p_data->remote.workmode.flag_work_warmdry)
 991   2                                      && (NO == p_data->remote.workmode.flag_work_colddry))
 992   2                              {
 993   3                                      s_work_min++;
 994   3                              }
 995   2                              break;
 996   2                      default:
 997   2                              break;
 998   2              }       
 999   1              if(s_work_min >= CLOCK_WORKTIME_120MIN)
1000   1              {
1001   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
1002   2              }
1003   1      }
1004          
1005          /*********************************************************************************************************
             -**************
1006          * Function Name: 
1007          * Description  : 
1008          * Arguments    : None
1009          * Return Value : None
1010          **********************************************************************************************************
             -*************/
1011          void fml_ctrl_deal_alarm(datall* p_data)
1012          {
1013   1              if((p_data->temperature.value >= ALARM_HIGH_TEMP))
1014   1              {
C51 COMPILER V9.01   XY_FML_CTRL                                                           03/20/2021 14:12:10 PAGE 18  

1015   2                      p_data->remote.workmode.workmode_current = WORKMODULE_STANDBY;
1016   2              }
1017   1      }
1018          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4658    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =     14      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
