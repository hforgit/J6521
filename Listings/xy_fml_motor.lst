C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/20/2021 13:50:48 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE XY_FML_MOTOR
OBJECT MODULE PLACED IN .\Objects\xy_fml_motor.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE 02_FML\xy_fml_motor.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\01_APL;.
                    -\02_FML;.\03_HAL;.\04_SYS) DEBUG PRINT(.\Listings\xy_fml_motor.lst) OBJECT(.\Objects\xy_fml_motor.obj)

line level    source

   1          #include "xy_sys_headfile.h"
   2          
   3          /*********************************************************************************************************
             -**************
   4          * Function Name: 
   5          * Description  : 
   6          * Arguments    : None
   7          * Return Value : None
   8          **********************************************************************************************************
             -*************/
   9          void fml_motor_init_data(datall* p_data)
  10          {
  11   1              memset((char *)&p_data->motor, 0, sizeof(p_data->motor));               //reset motor step
  12   1      
  13   1              p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;
  14   1              p_data->motor.blow_motor_step_pri   = TARGET_HIGH_SWING;
  15   1              
  16   1              p_data->motor.blow_motor_step           = MAX_RESET_STEP;                       ///< checkself max step
  17   1              
  18   1              p_data->motor.switch_motor_step = MAX_RESET_STEP;                       ///< checkself max step
  19   1      }
  20          
  21          /*********************************************************************************************************
             -**************
  22          * Function Name: 
  23          * Description  : 
  24          * Arguments    : None
  25          * Return Value : None
  26          **********************************************************************************************************
             -*************/
  27          void fml_motor_reset_step(motorcontrol* p_motor)
  28          {
  29   1              static switchstate s_onetime[2] = {RESET, RESET};
  30   1              static switchstate s_resetstep = STEP1;
  31   1      
  32   1              if(STEP2 == s_resetstep)
  33   1              {
  34   2                      if(RESET_STEP_ZERO == p_motor->blow_target_step)
  35   2                      {
  36   3                              if(RESET_STEP_ZERO == p_motor->blow_motor_step)
  37   3                              {
  38   4                                      if(RESET == s_onetime[0])
  39   4                                      {
  40   5                                              s_onetime[0] = SET;
  41   5                                              p_motor->blow_motor_step = COMPENSATE_STEP;
  42   5                                      }
  43   4                              }
  44   3                      }
  45   2                      else
  46   2                      {
  47   3                              s_onetime[0] = RESET;
  48   3                      }
  49   2                      p_motor->blow_target_step_real = p_motor->blow_target_step;
  50   2                      if(RESET_STEP_ZERO == p_motor->switch_target_step)
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/20/2021 13:50:48 PAGE 2   

  51   2                      {
  52   3                              if(RESET_STEP_ZERO == p_motor->switch_motor_step)
  53   3                              {
  54   4                                      if(RESET == s_onetime[1])
  55   4                                      {
  56   5                                              s_onetime[1] = SET;
  57   5                                              p_motor->switch_motor_step = COMPENSATE_STEP;
  58   5                                      }
  59   4                              }
  60   3                      }
  61   2                      else
  62   2                      {
  63   3                              s_onetime[1] = RESET;
  64   3                      }
  65   2                      p_motor->switch_target_step_real = p_motor->switch_target_step;
  66   2                      
  67   2              }
  68   1              else
  69   1              {
  70   2                      /* only enter work one time about checkself. */
  71   2                      p_motor->blow_target_step_real = RESET_STEP_ZERO;
  72   2                      p_motor->switch_target_step_real = RESET_STEP_ZERO;
  73   2                      if((RESET_STEP_ZERO == p_motor->blow_motor_step)
  74   2                              && (RESET_STEP_ZERO == p_motor->switch_motor_step))
  75   2                      {
  76   3                              s_resetstep = STEP2;
  77   3                      }
  78   2              }
  79   1      }
  80          
  81          /*********************************************************************************************************
             -**************
  82          * Function Name: 
  83          * Description  : 
  84          * Arguments    : None
  85          * Return Value : None
  86          **********************************************************************************************************
             -*************/
  87          void fml_motor_timer_ctrl(datall* p_data)
  88          {
  89   1              static unsigned char s_count = 0;
  90   1      
  91   1              if(ON == p_data->remote.keyctrl.keystate_open_swing)  
  92   1              {
  93   2                      s_count++;
  94   2                      if(s_count > 2)
  95   2                      {
  96   3                              s_count = 0;
  97   3                              hal_timer_motor_blow(&p_data->motor);
  98   3                      }
  99   2              }
 100   1              else
 101   1              {
 102   2                      hal_timer_motor_blow(&p_data->motor);
 103   2              }
 104   1              
 105   1              hal_timer_motor_switch(&p_data->motor);
 106   1      }
 107          
 108          /*********************************************************************************************************
             -**************
 109          * Function Name: 
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/20/2021 13:50:48 PAGE 3   

 110          * Description  : 
 111          * Arguments    : None
 112          * Return Value : None
 113          **********************************************************************************************************
             -*************/
 114          void fml_motor_blow_step(unsigned char n)
 115          {
 116   1              switch(n)
 117   1              {
 118   2                      case 0:
 119   2                              blow_motor_step1_on();blow_motor_step2_off();blow_motor_step3_off();blow_motor_step4_off();
 120   2                              break;
 121   2                      case 1:
 122   2                              blow_motor_step1_on();blow_motor_step2_on();blow_motor_step3_off();blow_motor_step4_off();
 123   2                              break;
 124   2                      case 2:
 125   2                              blow_motor_step1_off();blow_motor_step2_on();blow_motor_step3_off();blow_motor_step4_off();
 126   2                              break;
 127   2                      case 3:
 128   2                              blow_motor_step1_off();blow_motor_step2_on();blow_motor_step3_on();blow_motor_step4_off();
 129   2                              break;  
 130   2                      case 4:
 131   2                              blow_motor_step1_off();blow_motor_step2_off();blow_motor_step3_on();blow_motor_step4_off();
 132   2                              break;
 133   2                      case 5:
 134   2                              blow_motor_step1_off();blow_motor_step2_off();blow_motor_step3_on();blow_motor_step4_on();
 135   2                              break;
 136   2                      case 6:
 137   2                              blow_motor_step1_off();blow_motor_step2_off();blow_motor_step3_off();blow_motor_step4_on();
 138   2                              break;
 139   2                      case 7:
 140   2                              blow_motor_step1_on();blow_motor_step2_off();blow_motor_step3_off();blow_motor_step4_on();
 141   2                              break;          
 142   2                      default:
 143   2                              break;
 144   2              }
 145   1      }
 146          
 147          /*********************************************************************************************************
             -**************
 148          * Function Name: 
 149          * Description  : 
 150          * Arguments    : None
 151          * Return Value : None
 152          **********************************************************************************************************
             -*************/
 153          void fml_motor_absorb_step(unsigned char n)
 154          {
 155   1              n = 7 - n;
 156   1      
 157   1              switch(n)
 158   1              {
 159   2                      case 0:
 160   2                              absorb_motor_step1_on();absorb_motor_step2_off();absorb_motor_step3_off();absorb_motor_step4_off();
 161   2                              break;
 162   2                      case 1:
 163   2                              absorb_motor_step1_on();absorb_motor_step2_on();absorb_motor_step3_off();absorb_motor_step4_off();
 164   2                              break;
 165   2                      case 2:
 166   2                              absorb_motor_step1_off();absorb_motor_step2_on();absorb_motor_step3_off();absorb_motor_step4_off();
 167   2                              break;
 168   2                      case 3:
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/20/2021 13:50:48 PAGE 4   

 169   2                              absorb_motor_step1_off();absorb_motor_step2_on();absorb_motor_step3_on();absorb_motor_step4_off();
 170   2                              break;
 171   2                      case 4:
 172   2                              absorb_motor_step1_off();absorb_motor_step2_off();absorb_motor_step3_on();absorb_motor_step4_off();
 173   2                              break;
 174   2                      case 5:
 175   2                              absorb_motor_step1_off();absorb_motor_step2_off();absorb_motor_step3_on();absorb_motor_step4_on();
 176   2                              break;
 177   2                      case 6:
 178   2                              absorb_motor_step1_off();absorb_motor_step2_off();absorb_motor_step3_off();absorb_motor_step4_on();
 179   2                              break;
 180   2                      case 7:
 181   2                              absorb_motor_step1_on();absorb_motor_step2_off();absorb_motor_step3_off();absorb_motor_step4_on();
 182   2                              break;
 183   2                      default:
 184   2                              break;
 185   2              }
 186   1              
 187   1      }
 188          
 189          /*********************************************************************************************************
             -**************
 190          * Function Name: 
 191          * Description  : 
 192          * Arguments    : None
 193          * Return Value : None
 194          **********************************************************************************************************
             -*************/
 195          void fml_motor_close_blow(void)
 196          {
 197   1              blow_motor_step1_off();
 198   1              blow_motor_step2_off();
 199   1              blow_motor_step3_off();
 200   1              blow_motor_step4_off();
 201   1      }
 202          
 203          /*********************************************************************************************************
             -**************
 204          * Function Name: 
 205          * Description  : 
 206          * Arguments    : None
 207          * Return Value : None
 208          **********************************************************************************************************
             -*************/
 209          void fml_motor_close_absorb(void)
 210          {
 211   1              absorb_motor_step1_off();
 212   1              absorb_motor_step2_off();
 213   1              absorb_motor_step3_off();
 214   1              absorb_motor_step4_off();
 215   1      }
 216          
 217          /*********************************************************************************************************
             -**************
 218          * Function Name: 
 219          * Description  : 
 220          * Arguments    : None
 221          * Return Value : None
 222          **********************************************************************************************************
             -*************/
 223          void fml_motor_blow_move(motorcontrol* p_motor)
 224          {
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/20/2021 13:50:48 PAGE 5   

 225   1              if(p_motor->blow_motor_step_delay_flag)
 226   1              {
 227   2                      p_motor->blow_motor_step_delay_flag=0;
 228   2                      p_motor->blow_motor_step_delay_count=0;
 229   2                      if(p_motor->blow_motor_step < p_motor->blow_target_step_real)
 230   2                      {
 231   3                              fml_motor_blow_step(p_motor->blow_motor_step%8);
 232   3                              p_motor->blow_motor_step++;
 233   3                      }
 234   2                      else if(p_motor->blow_motor_step > p_motor->blow_target_step_real)
 235   2                      {
 236   3                              fml_motor_blow_step(p_motor->blow_motor_step%8);
 237   3                              p_motor->blow_motor_step--;
 238   3                      }
 239   2                      else
 240   2                      {
 241   3                              fml_motor_close_blow();
 242   3                      }
 243   2              }
 244   1      }
 245          
 246          /*********************************************************************************************************
             -**************
 247          * Function Name: 
 248          * Description  : 
 249          * Arguments    : None
 250          * Return Value : None
 251          **********************************************************************************************************
             -*************/
 252          void fml_motor_switch_move(motorcontrol* p_motor)
 253          {
 254   1              if(p_motor->switch_motor_step_delay_flag)
 255   1              {
 256   2                      p_motor->switch_motor_step_delay_flag=0;
 257   2                      p_motor->switch_motor_step_delay_count=0;
 258   2                      if(p_motor->switch_motor_step < p_motor->switch_target_step_real)
 259   2                      {
 260   3                              fml_motor_absorb_step(p_motor->switch_motor_step%8);
 261   3                              p_motor->switch_motor_step++;
 262   3                      }
 263   2                      else if(p_motor->switch_motor_step > p_motor->switch_target_step_real)
 264   2                      {
 265   3                              fml_motor_absorb_step(p_motor->switch_motor_step%8);
 266   3                              p_motor->switch_motor_step--;
 267   3                      }
 268   2                      else
 269   2                      {
 270   3                              fml_motor_close_absorb();
 271   3                      }
 272   2              }
 273   1      }
 274          
 275          /*********************************************************************************************************
             -**************
 276          * Function Name: 
 277          * Description  : 
 278          * Arguments    : None
 279          * Return Value : None
 280          **********************************************************************************************************
             -*************/
 281          void fml_motor_save_step(datall* p_data)
 282          {
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/20/2021 13:50:48 PAGE 6   

 283   1              if(((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 284   1                      || (WORKMODULE_WARM == p_data->remote.workmode.workmode_current)))
 285   1              {
 286   2                      if((ON == p_data->remote.keyctrl.keystate_fan_blow) && (p_data->motor.blow_motor_step > TARGET_LOW_SWING
             -))
 287   2                      {
 288   3                              p_data->motor.blow_motor_step_pri = p_data->motor.blow_motor_step;
 289   3                      }
 290   2              }
 291   1      }
 292          /*********************************************************************************************************
             -**************
 293          * Function Name: 
 294          * Description  : 
 295          * Arguments    : None
 296          * Return Value : None
 297          **********************************************************************************************************
             -*************/
 298          void fml_motor_ctrl_move(datall* p_data)
 299          {
 300   1              #ifdef XY_SYS_TEST_MODE
 301   1                      if(YES == p_data->testmode)
 302   1                              return;
 303   1              #endif
 304   1      
 305   1              fml_motor_reset_step(&p_data->motor);
 306   1              fml_motor_blow_move(&p_data->motor);
 307   1              
 308   1              fml_motor_switch_move(&p_data->motor);
 309   1              fml_motor_save_step(p_data);
 310   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    871    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
