C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/18/2021 08:37:08 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE XY_FML_MOTOR
OBJECT MODULE PLACED IN .\Objects\xy_fml_motor.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE 02_FML\xy_fml_motor.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\01_APL;.
                    -\02_FML;.\03_HAL;.\04_SYS) DEBUG PRINT(.\Listings\xy_fml_motor.lst) OBJECT(.\Objects\xy_fml_motor.obj)

line level    source

   1          #include "xy_sys_headfile.h"
   2          
   3          /*********************************************************************************************************
             -**************
   4          * Function Name: 
   5          * Description  : 
   6          * Arguments    : None
   7          * Return Value : None
   8          **********************************************************************************************************
             -*************/
   9          void fml_motor_init_data(datall* p_data)
  10          {
  11   1              memset((char *)&p_data->motor, 0, sizeof(p_data->motor));                               //reset motor step
  12   1      
  13   1              p_data->motor.blow_target_step_pri      = TARGET_LOW_SWING;
  14   1              p_data->motor.blow_motor_step_pri   = TARGET_HIGH_SWING;
  15   1              
  16   1              p_data->motor.blow_motor_step           = MAX_RESET_STEP;                       ///< checkself max step
  17   1              p_data->motor.absorb_motor_step = MAX_RESET_STEP;                       ///< checkself max step
  18   1      }
  19          
  20          /*********************************************************************************************************
             -**************
  21          * Function Name: 
  22          * Description  : 
  23          * Arguments    : None
  24          * Return Value : None
  25          **********************************************************************************************************
             -*************/
  26          void fml_motor_reset_step(motorcontrol* p_motor)
  27          {
  28   1              static switchstate s_onetime[2] = {RESET, RESET};
  29   1              static switchstate s_resetstep = STEP1;
  30   1              
  31   1              if(STEP2 == s_resetstep)
  32   1              {
  33   2                      if(RESET_STEP_ZERO == p_motor->blow_target_step)
  34   2                      {
  35   3                              if(RESET_STEP_ZERO == p_motor->blow_motor_step)
  36   3                              {
  37   4                                      if(RESET == s_onetime[0])
  38   4                                      {
  39   5                                              s_onetime[0] = SET;
  40   5                                              p_motor->blow_motor_step = COMPENSATE_STEP;
  41   5                                      }
  42   4                              }
  43   3                      }
  44   2                      else
  45   2                      {
  46   3                              s_onetime[0] = RESET;
  47   3                      }
  48   2                      p_motor->blow_target_step_real = p_motor->blow_target_step;
  49   2                              if(RESET_STEP_ZERO == p_motor->absorb_target_step)
  50   2                              {
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/18/2021 08:37:08 PAGE 2   

  51   3                                      if(RESET_STEP_ZERO == p_motor->absorb_motor_step)
  52   3                                      {
  53   4                                              if(RESET == s_onetime[1])
  54   4                                              {
  55   5                                                      s_onetime[1] = SET;
  56   5                                                      p_motor->absorb_motor_step = COMPENSATE_STEP;
  57   5                                              }
  58   4                                      }
  59   3                              }
  60   2                              else
  61   2                              {
  62   3                                      s_onetime[1] = RESET;
  63   3                              }
  64   2                              p_motor->absorb_target_step_real = p_motor->absorb_target_step;
  65   2              }
  66   1              else
  67   1              {
  68   2                      /* only enter work one time about checkself. */
  69   2                      p_motor->blow_target_step_real = RESET_STEP_ZERO;
  70   2                              p_motor->absorb_target_step_real = RESET_STEP_ZERO;
  71   2                              if((RESET_STEP_ZERO == p_motor->blow_motor_step)
  72   2                                      && (RESET_STEP_ZERO == p_motor->absorb_motor_step))
  73   2                              {
  74   3                                      s_resetstep = STEP2;
  75   3                              }
  76   2              }
  77   1      }
  78          
  79          /*********************************************************************************************************
             -**************
  80          * Function Name: 
  81          * Description  : 
  82          * Arguments    : None
  83          * Return Value : None
  84          **********************************************************************************************************
             -*************/
  85          void fml_motor_timer_ctrl(datall* p_data)
  86          {
  87   1              static unsigned char s_count = 0;
  88   1      
  89   1              if(ON == p_data->remote.keyctrl.keystate_open_swing)  
  90   1              {
  91   2                      s_count++;
  92   2                      if(s_count > 2)
  93   2                      {
  94   3                              s_count = 0;
  95   3                              hal_timer_motor_blow(&p_data->motor);
  96   3                      }
  97   2              }
  98   1              else
  99   1              {
 100   2                      hal_timer_motor_blow(&p_data->motor);
 101   2              }
 102   1              hal_timer_motor_absorb(&p_data->motor);
 103   1      }
 104          
 105          /*********************************************************************************************************
             -**************
 106          * Function Name: 
 107          * Description  : 
 108          * Arguments    : None
 109          * Return Value : None
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/18/2021 08:37:08 PAGE 3   

 110          **********************************************************************************************************
             -*************/
 111          void fml_motor_blow_step(unsigned char n)
 112          {
 113   1              n = 7 - n;
 114   1              
 115   1              switch(n)
 116   1              {
 117   2                      case 0:
 118   2                              blow_motor_step1_on();blow_motor_step2_off();blow_motor_step3_off();blow_motor_step4_off();
 119   2                              break;
 120   2                      case 1:
 121   2                              blow_motor_step1_on();blow_motor_step2_on();blow_motor_step3_off();blow_motor_step4_off();
 122   2                              break;
 123   2                      case 2:
 124   2                              blow_motor_step1_off();blow_motor_step2_on();blow_motor_step3_off();blow_motor_step4_off();
 125   2                              break;
 126   2                      case 3:
 127   2                              blow_motor_step1_off();blow_motor_step2_on();blow_motor_step3_on();blow_motor_step4_off();
 128   2                              break;  
 129   2                      case 4:
 130   2                              blow_motor_step1_off();blow_motor_step2_off();blow_motor_step3_on();blow_motor_step4_off();
 131   2                              break;
 132   2                      case 5:
 133   2                              blow_motor_step1_off();blow_motor_step2_off();blow_motor_step3_on();blow_motor_step4_on();
 134   2                              break;
 135   2                      case 6:
 136   2                              blow_motor_step1_off();blow_motor_step2_off();blow_motor_step3_off();blow_motor_step4_on();
 137   2                              break;
 138   2                      case 7:
 139   2                              blow_motor_step1_on();blow_motor_step2_off();blow_motor_step3_off();blow_motor_step4_on();
 140   2                              break;          
 141   2                      default:
 142   2                              break;
 143   2              }
 144   1      }
 145          
 146          /*********************************************************************************************************
             -**************
 147          * Function Name: 
 148          * Description  : 
 149          * Arguments    : None
 150          * Return Value : None
 151          **********************************************************************************************************
             -*************/
 152          void fml_motor_absorb_step(unsigned char n)
 153          {
 154   1              switch(n)
 155   1              {
 156   2                      case 0:
 157   2                              absorb_motor_step1_on();absorb_motor_step2_off();absorb_motor_step3_off();absorb_motor_step4_off();
 158   2                              break;
 159   2                      case 1:
 160   2                              absorb_motor_step1_on();absorb_motor_step2_on();absorb_motor_step3_off();absorb_motor_step4_off();
 161   2                              break;
 162   2                      case 2:
 163   2                              absorb_motor_step1_off();absorb_motor_step2_on();absorb_motor_step3_off();absorb_motor_step4_off();
 164   2                              break;
 165   2                      case 3:
 166   2                              absorb_motor_step1_off();absorb_motor_step2_on();absorb_motor_step3_on();absorb_motor_step4_off();
 167   2                              break;
 168   2                      case 4:
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/18/2021 08:37:08 PAGE 4   

 169   2                              absorb_motor_step1_off();absorb_motor_step2_off();absorb_motor_step3_on();absorb_motor_step4_off();
 170   2                              break;
 171   2                      case 5:
 172   2                              absorb_motor_step1_off();absorb_motor_step2_off();absorb_motor_step3_on();absorb_motor_step4_on();
 173   2                              break;
 174   2                      case 6:
 175   2                              absorb_motor_step1_off();absorb_motor_step2_off();absorb_motor_step3_off();absorb_motor_step4_on();
 176   2                              break;
 177   2                      case 7:
 178   2                              absorb_motor_step1_on();absorb_motor_step2_off();absorb_motor_step3_off();absorb_motor_step4_on();
 179   2                              break;
 180   2                      default:
 181   2                              break;
 182   2              }
 183   1      }
 184          
 185          /*********************************************************************************************************
             -**************
 186          * Function Name: 
 187          * Description  : 
 188          * Arguments    : None
 189          * Return Value : None
 190          **********************************************************************************************************
             -*************/
 191          void fml_motor_close_blow(void)
 192          {
 193   1              blow_motor_step1_off();
 194   1              blow_motor_step2_off();
 195   1              blow_motor_step3_off();
 196   1              blow_motor_step4_off();
 197   1      }
 198          
 199          /*********************************************************************************************************
             -**************
 200          * Function Name: 
 201          * Description  : 
 202          * Arguments    : None
 203          * Return Value : None
 204          **********************************************************************************************************
             -*************/
 205          void fml_motor_close_absorb(void)
 206          {
 207   1              absorb_motor_step1_off();
 208   1              absorb_motor_step2_off();
 209   1              absorb_motor_step3_off();
 210   1              absorb_motor_step4_off();
 211   1      }
 212          
 213          /*********************************************************************************************************
             -**************
 214          * Function Name: 
 215          * Description  : 
 216          * Arguments    : None
 217          * Return Value : None
 218          **********************************************************************************************************
             -*************/
 219          void fml_motor_blow_move(motorcontrol* p_motor)
 220          {
 221   1              if(p_motor->blow_motor_step_delay_flag)
 222   1              {
 223   2                      p_motor->blow_motor_step_delay_flag=0;
 224   2                      p_motor->blow_motor_step_delay_count=0;
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/18/2021 08:37:08 PAGE 5   

 225   2                      if(p_motor->blow_motor_step < p_motor->blow_target_step_real)
 226   2                      {
 227   3                              fml_motor_blow_step(p_motor->blow_motor_step%8);
 228   3                              p_motor->blow_motor_step++;
 229   3                      }
 230   2                      else if(p_motor->blow_motor_step > p_motor->blow_target_step_real)
 231   2                      {
 232   3                              fml_motor_blow_step(p_motor->blow_motor_step%8);
 233   3                              p_motor->blow_motor_step--;
 234   3                      }
 235   2                      else
 236   2                      {
 237   3                              fml_motor_close_blow();
 238   3                      }
 239   2              }
 240   1      }
 241          
 242          /*********************************************************************************************************
             -**************
 243          * Function Name: 
 244          * Description  : 
 245          * Arguments    : None
 246          * Return Value : None
 247          **********************************************************************************************************
             -*************/
 248          void fml_motor_absorb_move(motorcontrol* p_motor)
 249          {
 250   1              if(p_motor->absorb_motor_step_delay_flag)
 251   1              {
 252   2                      p_motor->absorb_motor_step_delay_flag=0;
 253   2                      p_motor->absorb_motor_step_delay_count=0;
 254   2                      if(p_motor->absorb_motor_step < p_motor->absorb_target_step_real)
 255   2                      {
 256   3                              fml_motor_absorb_step(p_motor->absorb_motor_step%8);
 257   3                              p_motor->absorb_motor_step++;
 258   3                      }
 259   2                      else if(p_motor->absorb_motor_step > p_motor->absorb_target_step_real)
 260   2                      {
 261   3                              fml_motor_absorb_step(p_motor->absorb_motor_step%8);
 262   3                              p_motor->absorb_motor_step--;           
 263   3                      }
 264   2                      else
 265   2                      {
 266   3                              fml_motor_close_absorb();
 267   3                      }
 268   2              }
 269   1      }
 270          
 271          /*********************************************************************************************************
             -**************
 272          * Function Name: 
 273          * Description  : 
 274          * Arguments    : None
 275          * Return Value : None
 276          **********************************************************************************************************
             -*************/
 277          void fml_motor_save_step(datall* p_data)
 278          {
 279   1              if(((WORKMODULE_BLOW == p_data->remote.workmode.workmode_current)
 280   1                      || (WORKMODULE_WARM == p_data->remote.workmode.workmode_current)))
 281   1              {
 282   2                      if((ON == p_data->remote.keyctrl.keystate_fan_blow) && (p_data->motor.blow_motor_step > TARGET_LOW_SWING
C51 COMPILER V9.01   XY_FML_MOTOR                                                          03/18/2021 08:37:08 PAGE 6   

             -))
 283   2                      {
 284   3                              p_data->motor.blow_motor_step_pri = p_data->motor.blow_motor_step;
 285   3                      }
 286   2              }
 287   1      }
 288          /*********************************************************************************************************
             -**************
 289          * Function Name: 
 290          * Description  : 
 291          * Arguments    : None
 292          * Return Value : None
 293          **********************************************************************************************************
             -*************/
 294          void fml_motor_ctrl_move(datall* p_data)
 295          {
 296   1              #ifdef XY_SYS_TEST_MODE
 297   1                      if(YES == p_data->testmode)
 298   1                              return;
 299   1              #endif
 300   1      
 301   1              fml_motor_reset_step(&p_data->motor);
 302   1              fml_motor_blow_move(&p_data->motor);
 303   1              fml_motor_absorb_move(&p_data->motor);
 304   1              fml_motor_save_step(p_data);
 305   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    871    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
